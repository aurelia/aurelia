# Internationalization

- [Internationalization](#internationalization)
  - [Introduction](#introduction)
  - [Getting Started](#getting-started)
  - [Installing the Plugin](#installing-the-plugin)
  - [Registering the plugin](#registering-the-plugin)
    - [Customize translation attribute alias](#customize-translation-attribute-alias)
    - [Managing translation resources](#managing-translation-resources)
      - [Bundling the resource files](#bundling-the-resource-files)
      - [i18next Backend plugin](#i18next-backend-plugin)
  - [Using the plugin](#using-the-plugin)
    - [Active locale](#active-locale)
    - [Translation](#translation)
      - [Translation in view](#translation-in-view)
        - [Syntax](#syntax)
        - [Replace `textContent`](#replace-textcontent)
        - [Replace `[src]` of `<img>`](#replace-src-of-img)
        - [Replace `innerHTML`](#replace-innerhtml)
        - [`[append]` or `[prepend]` translations](#append-or-prepend-translations)
        - [Attribute translation](#attribute-translation)
        - [Manipulate translations with `t-params` attribute](#manipulate-translations-with-t-params-attribute)
          - [Interpolation](#interpolation)
          - [Contextual translation](#contextual-translation)
          - [Pluralization](#pluralization)
          - [Interval specific translation](#interval-specific-translation)
        - [ValueConverter and BindingBehavior](#valueconverter-and-bindingbehavior)
      - [Translation via code](#translation-via-code)
    - [Formatting numbers](#formatting-numbers)
      - [Format number in view using ValueConverter and/or BindingBehavior](#format-number-in-view-using-valueconverter-andor-bindingbehavior)
      - [Format number via code](#format-number-via-code)
    - [Unformat number via code](#unformat-number-via-code)
    - [Formatting dates](#formatting-dates)
      - [Format date in view using ValueConverter and/or BindingBehavior](#format-date-in-view-using-valueconverter-andor-bindingbehavior)
      - [Format date via code](#format-date-via-code)
    - [relative time format](#relative-time-format)
  - [Migration Guide & Breaking Changes](#migration-guide--breaking-changes)

## Introduction

This documentation explains how to get up and running with Aurelia-I18N in order to provide localization and internationalization features with your app.

Under the hood it uses [i18next](http://i18next.com/), which is a generalized open source library with an extensive set of features.
By building on top of it not only can you reuse your work across various other platforms and frameworks but you are able to use an extensive eco-system full of various packages.

If you already familiar with `i18next` you would know that a key along with an optional options object, to manipulate the translation are used to produce the final translated output.
`@aurelia/i18n` also uses similar concept of key and options object.
The evaluated keys and the options object are passed on to `i18next` as-is.
This means that any resource syntax (interpolation, context, nesting etc.), and options object schema supported by `i18next` are also supported by `@aurelia/i18n` by default.

## Getting Started

> Note
> If you have already used `aurelia-i18n` plugin previously and are looking for the migrating your existing Aurelia app to Aurelia vNext then [jump to migration guide](#migration-guide--breaking-changes).

Install the plugin.

```
npm i @aurelia/i18n
```

Register the plugin in your app.

```typescript
import { I18nConfiguration } from '@aurelia/i18n';
import { Aurelia } from '@aurelia/runtime';

new Aurelia()
  .register(
    I18nConfiguration.customize((options) => {
      options.initOptions = {
        resources: {
          en: { translation: { key: "Hello I18N"} },
          de: { translation: { key: "Hallo I18N"} },
        }
      };
    })
  )
  .app({ host, component })
  .start();
```

The above example shows how to initialize the i18n plugin and thereby i18next with translation resources.
There are alternatives of doing that, which is discussed [later](#managing-translation-resources).
Once registered, the plugin can be used in view using the translation attribute (default attribute is `t`, though [alias can be configured](#customize-translation-attribute-alias)), and the translation keys configured.

```html
<span t="key"></span>
```

During runtime, Aurelia will replace the `textContent` of the `span` with the string "Hello I18N", considering the currently active locale is `en`.
If you [change the locale](#active-locale) to `de` for example, then on runtime, the text will be changed to "Hallo I18N".

That was just the "hello world" example of `@aurelia/i18n`.
The plugin can do more than just that; for details read on.

## Installing the Plugin

* Aurelia CLI
* JSPM ??
* Webpack
* other ??

## Registering the plugin

As told earlier, the plugin uses `i18next` under the hood.
During registration, the [options to initialize `i18next`](https://www.i18next.com/overview/api#init) can be passed on.
There are 2 ways the plugin can be registered.
- Default options
  ```typescript
  new Aurelia().register(I18nConfiguration)
  ```
  This initialize the plugin, as well as `i18next` with default options.
  However, often the default settings will not suffice.
- Customized options
  ```typescript
  new Aurelia()
    .register(I18nConfiguration.customize((options)=>{
      options.initOptions = {
        resources: {
          en: { translation: { key: "Hello I18N"} },
          de: { translation: { key: "Hallo I18N"} },
        }
      };
    }));
  ```
  The `customize` function with a callback can be used to customize the initialization of `i18next` (other use-cases follow).
  The `options.initOptions` can be mutated to affect the initialization of `i18next`.
  Every options that can be used in [`i18next.init`](https://www.i18next.com/overview/api#init) can be used here.

  Additionally, any [`i18next` plugins](https://www.i18next.com/overview/plugins-and-utils) can be used using `options.initOptions.plugins` array, as shown below.

  ```typescript
  import * as intervalPlural from 'i18next-intervalplural-postprocessor';

  new Aurelia()
   .register(I18nConfiguration.customize((options)=>{
     options.initOptions = {
       plugins: [intervalPlural] // depending on your tsconfig this might also be intervalPlural.default
     };
   }));
  ```

  A common use-case of `i18next` plugin in described [here](#i18next-backend-plugin).

### Customize translation attribute alias
As you may have already noticed that in view translated resources can be accessed using the following syntax.

```html
<element t="key"></element>
```

The `t` attribute (find the details [here](#translation)) is used by the plugin by default.
In case that creates a conflict (maybe there is an existing custom attribute named `t` in your app), an alias of this attribute can be registered as follows.

```typescript
new Aurelia()
  .register(
    I18nConfiguration.customize((options) => {
      options.translationAttributeAliases = ['i18n', 'tr'];
    })
  )
```

The registered aliases can then be used in view in place of `t`, as shown below.

```html
<element i18n="key1"></element>
<element tr="key2"></element>
```

### Managing translation resources

Typically that the translation resources used in `i18next` is plain JSON objects.
If you are unfamiliar such translation resources, it takes following form.

```json
{
  "key": "value of key",
  "complex": {
    "nested": {
      "resource": {
        "key": "value of nested resource key"
      }
    }
  }
}
```
For this example, the key expression `key` will be evaluated to `'value of key'`, whereas `complex.nested.resource.key` will be evaluated to `'value of nested resource key'`.
In the previous examples, the resources are defined inline.
As the application grows, it is likely that the translation resource will also grow with that.
With that the inline resources gets cumbersome.
A typical practice is to externalize the JSON resources to its own file.
There are two approaches how those files can be used in the application which are elaborated in the following sections.

#### Bundling the resource files

A straightforward approach would be to import the JSON resources to app (depending on your build system), and use those in the `customize` function.
The example below shows how to do that.

```typescript
import * as de from 'path_to_locales/de/translation.json';
import * as en from 'path_to_locales/en/translation.json';

new Aurelia()
  .register(
    I18nConfiguration.customize((options) => {
      options.initOptions = {
        resources: {
          en: { translation: en },
          de: { translation: de },
        }
      };
    })
  );
```

This is quite handy strategy for small app, with trivial amount of translated text.
However, if there are multiple languages supported in your app, and the amount of translations for each locale is non-trivial, then this might not be the optimal choice, considering your build system supports bundling.
The reason being that all the translation resources gets bundled with the app, even if all the resources are not used in real time.
Thus, this approach might increase the bundle size needlessly, which in turn might affect the startup time of your app.

#### i18next Backend plugin

Another approach is to asynchronously load the resource file when needed.
To this end, [`i18next` Backend plugins](https://www.i18next.com/overview/plugins-and-utils#backends) can be used.
Whenever, the language is changed in `i18next`, it will use the registered Backend to fetch the resource files, so that keys can be translated for the new locale.

For this example, we use [`i18next-fetch-backend`](https://github.com/perrin4869/i18next-fetch-backend) that uses `fetch` to load the resource files.

```typescript
import Fetch from 'i18next-fetch-backend';

new Aurelia()
  .register(
    I18nConfiguration.customize((options) => {
      options.initOptions = {
        plugins: [Fetch],
        backend: {
          loadPath: '/locales/{{lng}}/{{ns}}.json',
        }
      };
    })
  );
```
This way, no translation resources get bundled with the app.
Instead `i18next` instructs the registered Backend to load the translation resource using the `loadPath` pattern `'/locales/{{lng}}/{{ns}}.json'` during initialization and whenever the active locale is changed.
Note that `{{lng}}`, and `{{ns}}` are placeholders for locale name, and namespace respectively.
The default namespace used by `i18next` is `translation` (which can of course be changed using init options).
For example, for locale `en`, it is expected that the a `translation.json` is available under `/locales/en`.
Thus, you have to ensure that those translation resources are accessible under correct path.

**Recipes**

This section shows couple of recipes to make those resources available for Backend.

- `webpack-dev-server`: Use `copy-webpack-plugin` to copy the `locales` src directory to distribution directory.
  Then set the `devServer.contentBase` to the distribution directory.

  ```javascript
  const path = require('path');
  const CopyPlugin = require('copy-webpack-plugin');

  module.exports = function() {
    return {
      devServer: {
        contentBase: path.join(__dirname, "dist"),
      },
      plugins: [
        new CopyPlugin([
          { from: 'src/locales', to: 'locales' } // assumption: src/locales exists
        ])
      ]
    }
  }
  ```
- cli: TODO

## Using the plugin

If you are familiar with `aurelia-i18n` plugin, then you know that apart from translation service, this plugin also provides formatting service for number, date, and relative time.
All these features are also available in `@aurelia/i18n` which are elaborated in the following section.

### Active locale

The active locale can be `get` or `set` by grabbing the instance of `I18nService` (in the previous version on Aurelia this was known as `I18N`), and using `getLocale()`, and `setLocale()` methods.
Following example shows how to manipulate the active locale.

```typescript my-demo-vm.ts
import { I18N, I18nService } from '@aurelia/i18n';

export class MyDemoVm {
  constructor(@I18N private readonly i18n: I18nService) {
    const currentLocale = this.i18n.getLocale();
  }

  public async changeLocale(locale: string) {
    await this.i18n.setLocale(locale);
  }
}
```

Note that when the active locale is changed, the `I18nService` publishes the `i18n:locale:changed` event, and dispatches the signal `aurelia-translation-signal`.
The i18n value-converters and binding-behaviors subscribe to these events, and updates the translation automatically.
This event and signal is a very useful tool if you want to perform your own custom locale-sensitive logic when the locale is changed.

> Note
> Unlike the previous version of Aurelia, in vNext all translatable resources (marked by the out of the box attributes, value converters, and binding behaviors) are updated automatically on change of locale, without the need of any additional component or service.

### Translation

The translation service provided by this plugin can be used both in view (HTML), and view-model.

#### Translation in view
Aurelia uses an attribute pattern in view to replace the content or attribute values.
The default pattern is `t`, which can be customized by [registering aliases](#customize-translation-attribute-alias).
For the purpose this discussion though the default attribute is assumed.

##### Syntax

```html
<element t="[optional-attribute-list1]translation-key;[optional-attribute-list2]optional-translation-key"></element>
```
At minimum, a `translation-key` needs to be used as the value for `t` attribute.
The key can be preceded by a comma-separated list of attributes.
When specified, the value of those attributes are replaced with the value of the translation key.
Moreover, subsequent attribute list and key pairs can also be used in the same `t` attribute.
The following examples explain this in more details.

##### Replace `textContent`

This is the most common use-case, as well as the default behavior.

```json translation.json
{
  "key": "Hello World"
}
```

```html view.html
<span t="key"></span>
```
Given the above translation, and the view, Aurelia replaces the `textContent` of the `span` with "Hello World".

Note that the key expression can also be constructed in view-model and be bound to `t` using `t.bind` syntax.

```typescript view.ts
class MyView {
  i18nKey = "key";
}
```
```html view.html
<span t.bind="i18nKey"></span>
```

##### Replace `[src]` of `<img>`

The aforementioned `t="key"` syntax behaves bit differently for `img` elements.
In this case, the `src` attribute of the `img` is replaced instead.

```json translation.json
{
  "key": "/path/to/image.jpg"
}
```

```html view.html
<img t="key">
```
`i18n` plugin transforms the `img` element to `<img src="/path/to/image.jpg">`.

##### Replace `innerHTML`

As told before, by default the plugin will set the `textContent` property of an element.

```json translation.json
{
  "title": "Title <b>bold</b>"
}
```

```html view.html
<span t="title">Title</span>
```

Therefore, in above example the html tags will be escaped and the output will be `&lt;b&gt;bold&lt;/b&gt;`.
To allow html-markup to be used, the `[html]` attribute needs to be added before the translation key.

```HTML
<span t="[html]title">Title</span>
```

This will set the `innerHTML` of the element instead of the `textContent` property, so html-markup won't be escaped.

##### `[append]` or `[prepend]` translations

So far we have seen that contents are replaced.
There are 2 special attributes `[append]`, and `[prepend]` which can be used to append or prepend content to the existing content of the element.

```json translation.json
{
  "pre": "tic ",
  "post": " toe",
}
```

```html view.html
<span t="[prepend]pre;[append]post">tac</span>
```

The example above produces `<span>tic tac toe</span>`.

##### Attribute translation

The plugin can be used to translate attributes of HTML elements.

```json translation.json
{
  "title": "some text",
}
```

```html view.html
<span t="[title]title"></span>
```

The example sets the `[title]` attribute of the `span`.
Some useful example would be to use the attribute translation to set the `[alt]` or `[title]` attributes of image.
Note that same key can also be used to target multiple attributes, for example: `<img t="[title,alt]key">`.

Similar syntax of attribute translation also works for translating `@bindable`s of custom elements.

```typescript custom-message.ts
import { bindable, customElement } from '@aurelia/runtime';.
import template from './custom-message.html';

@customElement({ name: 'custom-message', template })
export class CustomMessage {
  @bindable public message: string;
}
```
```html custom-message.html
<template>
  <span>${message}</span>
</template>
```

Use the custom element as follows.

```html view.html
<custom-message t="[message]bar"></custom-message>
```

This produces following result.
```html
<custom-message>
  <span>[TRANSLATED VALUE OF BAR KEY]</span>
</custom-message>
```

##### Manipulate translations with `t-params` attribute

So far we have seen the simple key to value mapping.
However, `i18next` supports more complex use-cases such as [interpolation](https://www.i18next.com/translation-function/interpolation), [context-specific translation](https://www.i18next.com/translation-function/context) etc.
This is done by passing an complex options object along with the key to `i18next`.

With `@aurelia/i18n`, the `t-params` attribute pattern along with `t` can be used to this end.
The object bound to `t-params` are passed on to `i18next` as-is.
This means that any options object schema supported by `i18next` for any particular operation will work in the same fashion.
However, following are some basic examples of this; for further details check out the `i18next` docs.

###### Interpolation

```json translation.json
{
  "key": "{{what}} is {{how}}"
}
```

```html view.html
<span t="key" t-params.bind="{ what: 'i18next', how: 'great' }"></span>
```

The above results in `<span>i18next is great</span>`.

###### Contextual translation

```json translation.json
{
  "status": "unknown'",
  "status_dispatched": "Your order has been dispatched",
  "status_delivered": "Your order has been delivered",
}
```

```html view.html
<span t="status" t-params.bind="{ context: 'dispatched' }"></span>
```

The above results in `<span>Your order has been dispatched</span>`.

###### Pluralization

```json translation.json
{
  "itemWithCount": "{{count}} item",
  "itemWithCount_plural": "{{count}} items"
}
```

```html view.html
<span t="itemWithCount" t-params.bind="{ count: 0 }"></span>
<span t="itemWithCount" t-params.bind="{ count: 1 }"></span>
<span t="itemWithCount" t-params.bind="{ count: 10 }"></span>
```

The above results in the following.

```html
<span>0 items</span>
<span>1 item</span>
<span>10 items</span>
```

###### Interval specific translation

Sometimes, simple plural context is not enough, and different translation is required based on different interval.
Note that this use case is not supported by out of the box by `i18next`.
For this, we need to use [i18next-intervalplural-postprocessor](https://github.com/i18next/i18next-intervalPlural-postProcessor) plugin and register it to the `@aurelia/i18n` as shown [here](#registering-the-plugin).

Then define the interval translation resource as follows.
Note that the example uses [nesting](https://www.i18next.com/translation-function/nesting).

```json translation.json
{
  "itemWithCount": "{{count}} item",
  "itemWithCount_plural": "{{count}} items",
  "itemWithCount_interval": "(0)$t(itemWithCount_plural);(1)$t(itemWithCount);(2-7)$t(itemWithCount_plural);(7-inf){a lot of items};",
}
```

```html view.html
<span t="itemWithCount_interval"  t-params.bind="{postProcess: 'interval', count: 0}"></span>
<span t="itemWithCount_interval"  t-params.bind="{postProcess: 'interval', count: 1}"></span>
<span t="itemWithCount_interval"  t-params.bind="{postProcess: 'interval', count: 2}"></span>
<span t="itemWithCount_interval"  t-params.bind="{postProcess: 'interval', count: 3}"></span>
<span t="itemWithCount_interval"  t-params.bind="{postProcess: 'interval', count: 6}"></span>
<span t="itemWithCount_interval"  t-params.bind="{postProcess: 'interval', count: 7}"></span>
<span t="itemWithCount_interval" t-params.bind="{postProcess: 'interval', count: 10}"></span>
```

This results in the following.

```html
<span>0 items</span>
<span>1 item</span>
<span>2 items</span>
<span>3 items</span>
<span>6 items</span>
<span>a lot of items</span>
<span>a lot of items</span>
```

##### ValueConverter and BindingBehavior

In order to do translations in a more declarative way from within your HTML markup you can use the `t` ValueConverter and BindingBehavior.

```html view.html
<span> ${'itemWithCount' | t : {count: 10}} </span>
<span> ${'itemWithCount' & t : {count: 10}} </span>
```

Combined with appropriate translation resource, the correct value will be rendered.
Note that the options object that follows `t` is same options object as discussed [earlier](#manipulate-translations-with-t-params-attribute).
Naturally, this value is optional.
Both the ValueConverter and BindingBehavior also update the translation out of the box when the active locale is changed.

#### Translation via code

Translating stuff via code works by using the method `I18nService#tr`.
You can pass in the `key` as its first parameter, followed by the optional second parameter `options`.

```typescript my-demo-vm.ts
import { I18N, I18nService } from '@aurelia/i18n';

export class MyDemoVm {
  private status: string = 'dispatched';

  constructor(@I18N private readonly i18n: I18nService) {
    const statusText = this.i18n.tr('status', { context: this.status });
  }
}
```

### Formatting numbers

`@aurelia/i18n` plugin provides number formatting service using [`Intl` API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat).

#### Format number in view using ValueConverter and/or BindingBehavior

```html view.html
<span> ${ 123456789.12 | nf } </span>
<span> ${ 123456789.12 & nf : undefined : 'de'} </span>

<span> ${ 123456789.12 | nf: {style:'currency', currency: 'EUR' } : 'de' } </span>
<span> ${ 123456789.12 & nf: {style:'currency', currency: 'USD' }} </span>
```

The `nf` ValueConverter and BindingBehavior can be used to format numbers in a declarative way from the view.
Both takes two optional arguments, apart from the number being formatted which are options, and locale respectively.
If these are omitted, the number is formatted using the default number formatting options and the currently active locale.
A specific locale can be passed on to format the number as per that locale.
If the input is not a number, then the original value is returned from these as-is.

The formatting options are used to affect how the number is formatted.
A prominent use-case for that is to format the number as currency.
For a full list of options look [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat#Parameters).

Note that both ValueConverter and BindingBehavior updates the formatted value when the active locale is changed.

#### Format number via code

Translating numbers via code works by using the method `I18nService#nf`.
You can pass in the number as its first parameter, followed by the optional parameters `options`, and `locales`.

```typescript my-demo-vm.ts
import { I18N, I18nService } from '@aurelia/i18n';

export class MyDemoVm {

  constructor(@I18N private readonly i18n: I18nService) {
    const formatted = this.i18n.nf(123456789.12); // 123,456,789.12 - considering the current locale to be en
    const formattedCurrency = this.i18n.nf(123456789.12, { style: 'currency', currency: 'EUR' }, 'de'); // 123.456.789,12 €
  }
}
```

Additionally, if needed an instance of `Intl.NumberFormat` can be created using `I18nService#createNumberFormat` method.

```typescript my-demo-vm.ts
import { I18N, I18nService } from '@aurelia/i18n';

export class MyDemoVm {

  constructor(@I18N private readonly i18n: I18nService) {
    const nf = this.i18n.createNumberFormat({ style: 'currency', currency: 'EUR' }, 'de');
    const formatted = nf.format(123456789.12); // 123.456.789,12 €
  }
}
```
This can be useful if you want to cache the `Intl.NumberFormat` instance and reuse that later.

> Note
> The `I18N#nf` in the previous version of Aurelia matches the `I18nService#createNumberFormat`, whereas `I18nService#nf` provides the formatted number instead.

### Unformat number via code

Numeric strings can be converted back to number using `I18nService#uf` method.
The method takes the numeric string as first argument, followed by an optional second argument for locale, as shown in the following example.

```typescript my-demo-vm.ts
import { I18N, I18nService } from '@aurelia/i18n';

export class MyDemoVm {

  constructor(@I18N private readonly i18n: I18nService) {
    // all of the strings are converted back to `123456789.12`
    const ufSimple = this.i18n.uf('123,456,789.12');
    const ufLocale = this.i18n.uf('123.456.789,12', 'de');
    const ufCurrency = this.i18n.uf('$ 123,456,789.12');
    const ufText = this.i18n.uf('123,456,789.12 foo bar');

    // sign is respected; thus in this case the converted number is `- 123456789.12`
    const ufMinus = this.i18n.uf('- 123,456,789.12');
  }
}
```

### Formatting dates

`@aurelia/i18n` plugin provides date formatting service using [`Intl` API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat).

#### Format date in view using ValueConverter and/or BindingBehavior

```typescript my-demo-vm.ts
export class MyDemoVm {
  public date = new Date(2019, 7, 20);
}
```

```html my-demo-vm.html
<span id="i18n-df-vc"> ${ date | df } </span> <!-- 8/20/2019 -->
<span id="i18n-df-vc-iso"> ${ '2019-08-10T13:42:35.209Z' | df } </span> <!-- 8/20/2019 -->
<span id="i18n-df-vc-int"> ${ 0 | df } </span> <!-- 1/1/1970 -->
<span id="i18n-df-vc-int-str"> ${ '0' | df } </span> <!-- 1/1/1970 -->

<span id="i18n-df-bb"> ${ date & df : {year:'2-digit', month:'2-digit', day:'2-digit'} : 'de' } </span> <!-- 20.08.19 -->
```

The `df` ValueConverter and BindingBehavior can be used to format dates in a declarative way from the view.
Both takes two optional arguments, apart from the date being formatted which are options, and locale respectively.
If these are omitted, the date is formatted using the default date formatting options and the currently active locale.
A specific locale can be passed on to format the date as per that locale.

The formatting options are used to affect how the date is formatted.
For a full list of options look [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat#Parameters).

The value being formatted does not need to be strictly a date object.
Apart from `Date` instance, both the ValueConverter and the BindingBehavior supports integer, integer string, and ISO 8601 date string as input.
In case, the input cannot be converted reliably to an instance of `Date`, the original input is returned as-is from these.
Note that a integer string or a integer input is considered as the number of milliseconds since the Unix epoch (for more details look [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#Syntax)).

Note that both ValueConverter and BindingBehavior updates the formatted value when the active locale is changed.

#### Format date via code

Translating date via code works by using the method `I18nService#df`.
You can pass in the date as its first parameter, followed by the optional parameters `options`, and `locales`.

```typescript my-demo-vm.ts
import { I18N, I18nService } from '@aurelia/i18n';

export class MyDemoVm {

  constructor(@I18N private readonly i18n: I18nService) {
    const df1 = this.i18n.df(new Date(2020, 1, 10)); // '2/10/2020'
    const df2 = this.i18n.df(new Date(2020, 1, 10), { month: '2-digit', day: 'numeric', year: 'numeric' }, 'de'); // '10.02.2020'
    const df3 = this.i18n.df(0); // '1/1/1970'
  }
}
```

Additionally, if needed an instance of `Intl.DateTimeFormat` can be created using `I18nService#createDateTimeFormat` method.

```typescript my-demo-vm.ts
import { I18N, I18nService } from '@aurelia/i18n';

export class MyDemoVm {

  constructor(@I18N private readonly i18n: I18nService) {
    const df = this.i18n.createDateTimeFormat({ month: '2-digit', day: 'numeric', year: 'numeric' }, 'de');
    const formatted = df.format(new Date(2020, 1, 10)); // '10.02.2020'
  }
}
```
This can be useful if you want to cache the `Intl.DateTimeFormat` instance and reuse that later.

> Note
> The `I18N#df` in the previous version of Aurelia matches the `I18nService#createDateTimeFormat`, whereas `I18nService#df` provides the formatted date instead.

### relative time format
  - View
    - VC
    - BB
  - VM

## Migration Guide & Breaking Changes

- `I18N` --> `I18nService`
- Change in API: nf, df
- relative time format
  - method in `I18nService` instead of a full-fledged class
  - registering translation resources is not required
  - polyfill might be needed for the browsers, do not yet support `Intl.RelativeTimeFormat`
  - no 'now' for <1s time diff; treated as 1s
- All VCs are now signalable

