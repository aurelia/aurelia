# Internationalization

- [Internationalization](#internationalization)
  - [Introduction](#introduction)
  - [Getting Started](#getting-started)
  - [Installing the Plugin](#installing-the-plugin)
  - [Registering the plugin](#registering-the-plugin)
    - [Customize translation attribute alias](#customize-translation-attribute-alias)
    - [Managing translation resources](#managing-translation-resources)
      - [Bundling the resource files](#bundling-the-resource-files)
      - [i18next Backend plugin](#i18next-backend-plugin)
  - [Using the plugin](#using-the-plugin)
    - [t](#t)
    - [date format](#date-format)
    - [date format](#date-format-1)
    - [number format](#number-format)
    - [relative time format](#relative-time-format)
    - [Unformat number from VM](#unformat-number-from-vm)
    - [Changing the locale](#changing-the-locale)
  - [Migration Guide & Breaking Changes](#migration-guide--breaking-changes)

## Introduction

This documentation explains how to get up and running with Aurelia-I18N
in order to provide localization and internationalization features with your app.

Under the hood it uses [i18next](http://i18next.com/), which is a generalized
open source library with an extensive set of features. By building on top of it
not only can you reuse your work across various other platforms and frameworks
but you are able to use an extensive eco-system full of various packages.

## Getting Started

> Note
> If you have already used `aurelia-i18n` plugin previously and are looking for the migrating your existing Aurelia app to Aurelia vNext then [jump to migration guide](#migration-guide--breaking-changes).

Install the plugin.

```
npm i @aurelia/i18n
```

Register the plugin in your app.

```typescript
import { I18nConfiguration } from '@aurelia/i18n';
import { Aurelia } from '@aurelia/runtime';

new Aurelia()
  .register(
    I18nConfiguration.customize((options) => {
      options.initOptions = {
        resources: {
          en: { translation: { key: "Hello I18N"} },
          de: { translation: { key: "Hallo I18N"} },
        }
      };
    })
  )
  .app({ host, component })
  .start();
```

The above example shows how to initialize the i18n plugin and thereby i18next with translation resources.
There are alternatives of doing that, which is discussed [later](#managing-translation-resources).
Once registered, the plugin can be used in view using the translation attribute (default attribute is `t`, though [alias can be configured](#customize-translation-attribute-alias)), and the translation keys configured.

```html
<span t="key"></span>
```

During runtime, Aurelia will replace the `textContent` of the `span` with the string "Hello I18N", considering the currently active locale is `en`.
If you [change the locale](#changing-the-locale) to `de` for example, then on runtime, the text will be changed to "Hallo I18N".

That was just the "hello world" example of `@aurelia/i18n`.
The plugin can do more than just that; for details read on.

## Installing the Plugin

* Aurelia CLI
* JSPM ??
* Webpack
* other ??

## Registering the plugin

As told earlier, the plugin uses `i18next` under the hood.
During registration, the [options to initialize `i18next`](https://www.i18next.com/overview/api#init) can be passed on.
There are 2 ways the plugin can be registered.
- Default options
  ```typescript
  new Aurelia().register(I18nConfiguration)
  ```
  This initialize the plugin, as well as `i18next` with default options.
  However, often the default settings will not suffice.
- Customized options
  ```typescript
  new Aurelia()
    .register(I18nConfiguration.customize((options)=>{
      options.initOptions = {
        resources: {
          en: { translation: { key: "Hello I18N"} },
          de: { translation: { key: "Hallo I18N"} },
        }
      };
    }));
  ```
  The `customize` function with a callback can be used to customize the initialization of `i18next` (other use-cases follow).
  The `options.initOptions` can be mutated to affect the initialization of `i18next`.
  Every options that can be used in [`i18next.init`](https://www.i18next.com/overview/api#init) can be used here.

  Additionally, any [`i18next` plugins](https://www.i18next.com/overview/plugins-and-utils) can be used using `options.initOptions.plugins` array, as shown below.

  ```typescript
  import * as intervalPlural from 'i18next-intervalplural-postprocessor';

  new Aurelia()
   .register(I18nConfiguration.customize((options)=>{
     options.initOptions = {
       plugins: [intervalPlural] // depending on your tsconfig this might also be intervalPlural.default
     };
   }));
  ```

  A common use-case of `i18next` plugin in described [here](#i18next-backend-plugin).

### Customize translation attribute alias
As you may have already noticed that in view translated resources can be accessed using the following syntax.

```html
<el t="key"></el>
```

The `t` attribute (find the details [here](#t)) is used by the plugin by default.
In case that creates a conflict (maybe there is an existing custom attribute named `t` in your app), an alias of this attribute can be registered as follows.

```typescript
new Aurelia()
  .register(
    I18nConfiguration.customize((options) => {
      options.translationAttributeAliases = ['i18n', 'tr'];
    })
  )
```

The registered aliases can then be used in view in place of `t`, as shown below.

```html
<el i18n="key1"></el>
<el tr="key2"></el>
```

### Managing translation resources

Typically that the translation resources used in `i18next` is plain JSON objects.
If you are unfamiliar such translation resources, it takes following form.

```json
{
  "key": "value of key",
  "complex": {
    "nested": {
      "resource": {
        "key": "value of nested resource key"
      }
    }
  }
}
```
For this example, the key expression `key` will be evaluated to `'value of key'`, whereas `complex.nested.resource.key` will be evaluated to `'value of nested resource key'`.
In the previous examples, the resources are defined inline.
As the application grows, it is likely that the translation resource will also grow with that.
With that the inline resources gets cumbersome.
A typical practice is to externalize the JSON resources to its own file.
There are two approaches how those files can be used in the application which are elaborated in the following sections.

#### Bundling the resource files

A straightforward approach would be to import the JSON resources to app (depending on your build system), and use those in the `customize` function.
The example below shows how to do that.

```typescript
import * as de from 'path_to_locales/de/translation.json';
import * as en from 'path_to_locales/en/translation.json';

new Aurelia()
  .register(
    I18nConfiguration.customize((options) => {
      options.initOptions = {
        resources: {
          en: { translation: en },
          de: { translation: de },
        }
      };
    })
  );
```

This is quite handy strategy for small app, with trivial amount of translated text.
However, if there are multiple languages supported in your app, and the amount of translations for each locale is non-trivial, then this might not be the optimal choice, considering your build system supports bundling.
The reason being that all the translation resources gets bundled with the app, even if all the resources are not used in real time.
Thus, this approach might increase the bundle size needlessly, which in turn might affect the startup time of your app.

#### i18next Backend plugin

Another approach is to asynchronously load the resource file when needed.
To this end, [`i18next` Backend plugins](https://www.i18next.com/overview/plugins-and-utils#backends) can be used.
Whenever, the language is changed in `i18next`, it will use the registered Backend to fetch the resource files, so that keys can be translated for the new locale.

For this example, we use [`i18next-fetch-backend`](https://github.com/perrin4869/i18next-fetch-backend) that uses `fetch` to load the resource files.

```typescript
import Fetch from 'i18next-fetch-backend';

new Aurelia()
  .register(
    I18nConfiguration.customize((options) => {
      options.initOptions = {
        plugins: [Fetch],
        backend: {
          loadPath: '/locales/{{lng}}/{{ns}}.json',
        }
      };
    })
  );
```
This way, no translation resources get bundled with the app.
Instead `i18next` instructs the registered Backend to load the translation resource using the `loadPath` pattern `'/locales/{{lng}}/{{ns}}.json'`.
Note that `{{lng}}` stands for locale name, and `{{ns}}` for namespace.
The default namespace used by `i18next` is `translation` (which can of cource be changed using init options).
For example, for locale `en`, it is expected that the a `translation.json` is available under `/locales/en`.
Thus, you have to ensure that those translation resources are accessible under correct path.

**Recipes**

This section shows couple of recipes to make those resources available for Backend.

- `webpack-dev-server`: Use `copy-webpack-plugin` to copy the `locales` src directory to distribution directory.
  Then set the `devServer.contentBase` to the distribution directory.

  ```javascript
  const path = require('path');
  const CopyPlugin = require('copy-webpack-plugin');

  module.exports = function() {
    return {
      devServer: {
        contentBase: path.join(__dirname, "dist"),
      },
      plugins: [
        new CopyPlugin([
          { from: 'src/locales', to: 'locales' } // assumption: src/locales exists
        ])
      ]
    }
  }
  ```

## Using the plugin

### t
  - View
    - textContent
    - [html]
    - [append]
    - [prepend]
    - img[src]
    - multiple target: `key1;[attr]key2`, `key1;[attr1,attr2]key2`
    - with options including some basic examples:
      - context
      - pluralization
      - nesting
      - interval
  - VM: I18nService API

### date format
  - View
    - VC
    - BB
  - VM

### date format
  - View
    - VC
    - BB
  - VM

### number format
  - View
    - VC
    - BB
  - VM

### relative time format
  - View
    - VC
    - BB
  - VM

### Unformat number from VM

### Changing the locale

## Migration Guide & Breaking Changes

- `I18N` --> `I18nService`
- Change in API: nf, df
- relative time format
  - method in `I18nService` instead of a full-fledged class
  - registering translation resources is not required
  - polyfill might be needed for the browsers, do not yet support `Intl.RelativeTimeFormat`
  - no 'now' for <1s time diff; treated as 1s
- All VCs are now signalable

