import { ArrayBindingElement, ArrayBindingPattern, BindingElement, ComputedPropertyName, ModifierFlags, ObjectBindingPattern, OmittedExpression, SpreadElement, SyntaxKind } from 'typescript';
import { ILogger } from '@aurelia/kernel';
import { Realm, ExecutionContext } from '../realm.js';
import { $EnvRec } from '../types/environment-record.js';
import { $String } from '../types/string.js';
import { $Any, $AnyNonEmpty, $AnyObject } from '../types/_shared.js';
import { $Empty } from '../types/empty.js';
import { $IteratorRecord } from '../globals/iteration.js';
import { $Error } from '../types/error.js';
import { I$Node, Context, $$PropertyName, $$AssignmentExpressionOrHigher, $$BindingName, $$DestructurableBinding } from './_shared.js';
import { $$ESModuleOrScript } from './modules.js';
import { $PropertyAssignment, $ShorthandPropertyAssignment, $SpreadAssignment, $NodeWithSpreadElements, $ArrayLiteralExpression, $NewExpression, $CallExpression } from './expressions.js';
import { $PropertyDeclaration } from './classes.js';
import { $GetAccessorDeclaration, $SetAccessorDeclaration, $MethodDeclaration } from './methods.js';
import { $EnumMember } from './types.js';
import { $Number } from '../types/number.js';
import { $ArrayExoticObject } from '../exotics/array.js';
import { $List } from '../types/list.js';
export declare type $$NamedDeclaration = ($GetAccessorDeclaration | $SetAccessorDeclaration | $MethodDeclaration | $PropertyAssignment | $ShorthandPropertyAssignment | $SpreadAssignment | $BindingElement | $EnumMember | $PropertyDeclaration);
export declare class $ComputedPropertyName implements I$Node {
    readonly node: ComputedPropertyName;
    readonly parent: $$NamedDeclaration;
    readonly ctx: Context;
    readonly idx: number;
    readonly mos: $$ESModuleOrScript;
    readonly realm: Realm;
    readonly depth: number;
    readonly logger: ILogger;
    readonly path: string;
    get $kind(): SyntaxKind.ComputedPropertyName;
    readonly $expression: $$AssignmentExpressionOrHigher;
    readonly PropName: $String | $Empty;
    constructor(node: ComputedPropertyName, parent: $$NamedDeclaration, ctx: Context, idx: number, mos?: $$ESModuleOrScript, realm?: Realm, depth?: number, logger?: ILogger, path?: string);
    Evaluate(ctx: ExecutionContext): $String | $Error;
    EvaluatePropName(ctx: ExecutionContext): $String | $Error;
}
export declare class $ObjectBindingPattern implements I$Node {
    readonly node: ObjectBindingPattern;
    readonly parent: $$DestructurableBinding;
    readonly ctx: Context;
    readonly idx: number;
    readonly mos: $$ESModuleOrScript;
    readonly realm: Realm;
    readonly depth: number;
    readonly logger: ILogger;
    readonly path: string;
    get $kind(): SyntaxKind.ObjectBindingPattern;
    readonly combinedModifierFlags: ModifierFlags;
    readonly $elements: readonly $BindingElement[];
    readonly BoundNames: readonly $String[];
    readonly ContainsExpression: boolean;
    readonly HasInitializer: boolean;
    readonly IsSimpleParameterList: boolean;
    constructor(node: ObjectBindingPattern, parent: $$DestructurableBinding, ctx: Context, idx: number, mos?: $$ESModuleOrScript, realm?: Realm, depth?: number, logger?: ILogger, path?: string);
    InitializeBinding(ctx: ExecutionContext, value: $AnyNonEmpty, environment: $EnvRec | undefined): $Any;
}
export declare type $$ArrayBindingElement = ($BindingElement | $OmittedExpression);
export declare function $$arrayBindingElement(node: ArrayBindingElement, parent: $ArrayBindingPattern, ctx: Context, idx: number): $$ArrayBindingElement;
export declare function $$arrayBindingElementList(nodes: readonly ArrayBindingElement[], parent: $ArrayBindingPattern, ctx: Context): readonly $$ArrayBindingElement[];
export declare function $bindingElementList(nodes: readonly BindingElement[], parent: $$BindingPattern, ctx: Context): readonly $BindingElement[];
export declare class $ArrayBindingPattern implements I$Node {
    readonly node: ArrayBindingPattern;
    readonly parent: $$DestructurableBinding;
    readonly ctx: Context;
    readonly idx: number;
    readonly mos: $$ESModuleOrScript;
    readonly realm: Realm;
    readonly depth: number;
    readonly logger: ILogger;
    readonly path: string;
    get $kind(): SyntaxKind.ArrayBindingPattern;
    readonly combinedModifierFlags: ModifierFlags;
    readonly $elements: readonly $$ArrayBindingElement[];
    readonly BoundNames: readonly $String[];
    readonly ContainsExpression: boolean;
    readonly HasInitializer: boolean;
    readonly IsSimpleParameterList: boolean;
    constructor(node: ArrayBindingPattern, parent: $$DestructurableBinding, ctx: Context, idx: number, mos?: $$ESModuleOrScript, realm?: Realm, depth?: number, logger?: ILogger, path?: string);
    InitializeBinding(ctx: ExecutionContext, value: $AnyObject, environment: $EnvRec | undefined): $Any;
    InitializeIteratorBinding(ctx: ExecutionContext, iteratorRecord: $IteratorRecord, environment: $EnvRec | undefined): $Any;
}
export declare type $$BindingPattern = ($ArrayBindingPattern | $ObjectBindingPattern);
export declare class $BindingElement implements I$Node {
    readonly node: BindingElement;
    readonly parent: $$BindingPattern;
    readonly ctx: Context;
    readonly idx: number;
    readonly mos: $$ESModuleOrScript;
    readonly realm: Realm;
    readonly depth: number;
    readonly logger: ILogger;
    readonly path: string;
    get $kind(): SyntaxKind.BindingElement;
    readonly modifierFlags: ModifierFlags;
    readonly combinedModifierFlags: ModifierFlags;
    readonly $propertyName: $$PropertyName | undefined;
    readonly $name: $$BindingName;
    readonly $initializer: $$AssignmentExpressionOrHigher | undefined;
    readonly BoundNames: readonly $String[];
    readonly ContainsExpression: boolean;
    readonly HasInitializer: boolean;
    readonly IsSimpleParameterList: boolean;
    constructor(node: BindingElement, parent: $$BindingPattern, ctx: Context, idx: number, mos?: $$ESModuleOrScript, realm?: Realm, depth?: number, logger?: ILogger, path?: string);
    InitializePropertyBinding(ctx: ExecutionContext, value: $AnyNonEmpty, environment: $EnvRec | undefined): $List<$String> | $Any;
    InitializeKeyedBinding(ctx: ExecutionContext, value: $AnyNonEmpty, environment: $EnvRec | undefined, propertyName: $String, initializer?: $$AssignmentExpressionOrHigher): $Any;
    InitializeIteratorBinding(ctx: ExecutionContext, iteratorRecord: $IteratorRecord, environment: $EnvRec | undefined): $Any;
}
export declare class $SpreadElement implements I$Node {
    readonly node: SpreadElement;
    readonly parent: $NodeWithSpreadElements;
    readonly ctx: Context;
    readonly idx: number;
    readonly mos: $$ESModuleOrScript;
    readonly realm: Realm;
    readonly depth: number;
    readonly logger: ILogger;
    readonly path: string;
    get $kind(): SyntaxKind.SpreadElement;
    readonly $expression: $$AssignmentExpressionOrHigher;
    constructor(node: SpreadElement, parent: $NodeWithSpreadElements, ctx: Context, idx: number, mos?: $$ESModuleOrScript, realm?: Realm, depth?: number, logger?: ILogger, path?: string);
    Evaluate(ctx: ExecutionContext): $List<$AnyNonEmpty> | $Error;
    AccumulateArray(ctx: ExecutionContext, array: $ArrayExoticObject, nextIndex: $Number): $Number | $Error;
}
export declare class $OmittedExpression implements I$Node {
    readonly node: OmittedExpression;
    readonly parent: $ArrayBindingPattern | $ArrayLiteralExpression | $NewExpression | $CallExpression;
    readonly ctx: Context;
    readonly idx: number;
    readonly mos: $$ESModuleOrScript;
    readonly realm: Realm;
    readonly depth: number;
    readonly logger: ILogger;
    readonly path: string;
    get $kind(): SyntaxKind.OmittedExpression;
    readonly BoundNames: readonly $String[];
    readonly ContainsExpression: false;
    readonly HasInitializer: false;
    readonly IsSimpleParameterList: false;
    constructor(node: OmittedExpression, parent: $ArrayBindingPattern | $ArrayLiteralExpression | $NewExpression | $CallExpression, ctx: Context, idx: number, mos?: $$ESModuleOrScript, realm?: Realm, depth?: number, logger?: ILogger, path?: string);
    EvaluateDestructuringAssignmentIterator(ctx: ExecutionContext, iteratorRecord: $IteratorRecord): $Any;
    Evaluate(ctx: ExecutionContext): $AnyNonEmpty;
}
//# sourceMappingURL=bindings.d.ts.map