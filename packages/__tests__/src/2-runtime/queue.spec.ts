import { queueAsyncTask, queueTask, yieldTasks } from '@aurelia/runtime';
import { assert, createFixture } from '@aurelia/testing';

describe('2-runtime/queue.spec.ts', function () {

  describe('queueTasks', function () {
    it('runs a task in the queue', async function () {
      let i = 0;
      queueTask(() => {
        i++;
      });
      assert.strictEqual(i, 0, 'Task should not have run yet');
      await yieldTasks();
      assert.strictEqual(i, 1, 'Task should have run once');
    });

    it('continuously runs until no more tasks queued', async function () {
      let i = 1;
      const callback = () => {
        if (i++ < 10) {
          queueTask(callback);
        }
      };
      queueTask(callback);

      try {
        await Promise.any([
          yieldTasks(),
          new Promise<void>((resolve) => setTimeout(resolve))
        ]);
        assert.strictEqual(i, 11, 'Task should have run 10 times');
      } catch (e) {
        assert.strictEqual(true, false, `Expected no error to be thrown. error: ${e}`);
      }
    });
  });

  describe('queueAsyncTask', function () {
    it('catches errors in the queue in an application', async function () {
      const { component, assertText } = createFixture(
        '<div>${text}</div>',
        class {
          i = 0;
          get text() {
            if (this.i === 1) {
              throw new Error('Test error');
            }
            return 'foo';
          }
        }
      );

      assertText('foo');
      component.i = 1;
      try {
        await yieldTasks();
        assert.strictEqual(true, false, 'Expected an error to be thrown');
      } catch(e) {
        // Expected error to be thrown
        assert.strictEqual(e.message, 'Test error');
      }
    });

    it('doesnt throw error when task is canceled before it runs', async function () {
      const task = queueAsyncTask(() => {
        throw new Error('This should not run');
      });
      task.cancel();
      await yieldTasks();
      assert.strictEqual(task.status, 'canceled', 'Task should be canceled');
    });

    it('yields error generated by task', async function () {
      queueAsyncTask(() => {
        throw new Error('Task error');
      });
      try {
        await yieldTasks();
        assert.strictEqual(true, false, 'Expected an error to be thrown');
      } catch (e) {
        assert.strictEqual(e.message, 'Task error', 'Expected task error to be thrown');
      }
    });
  });
});
