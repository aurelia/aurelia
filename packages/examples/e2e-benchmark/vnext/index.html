<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Aurelia</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta http-equiv="cache-control" content="max-age=0" />
  <meta http-equiv="cache-control" content="no-cache" />
  <meta http-equiv="expires" content="0" />
  <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
  <meta http-equiv="pragma" content="no-cache" />
  <script>
    function getAureliaMeasurements() {
      const measurements = performance.getEntriesByType('measure');
      const ii = measurements.length;
      const results = Array(ii);
      for (let i = 0; i < ii; ++i) {
        const measurement = measurements[i];
        results[i] = { name: measurement.name, duration: (measurement.duration + 0.5) | 0, startTime: (measurement.startTime + 0.5) | 0 };
      }
      return results;
    }
    class Instrumenter {
      constructor() {
        this.queuedActions = [];
        this.previousLifecycle = null;
        this.changeSet = null;
        this.queued = false;
      }
      flushChanges() {
        const changeSet = this.changeSet;
        if (changeSet !== null) {
          if (!this.queued) {
            this.queued = true;
            changeSet.flushed.then(() => {
              for (let i = 0, ii = actions.length; i < ii; ++i) {
                this.markActionEnd(actions[i]);
              }
              this.queuedActions = [];
              this.queued = false;
            });
          }
          const actions = this.queuedActions;
          if (changeSet.size > 0) {
            // we're trying to get to the end of the queue for the full measurement, so keep re-queueing until this flush is the last change
            for (let i = 0, ii = actions.length; i < ii; ++i) {
              const name = actions[i];
              const flushCount = ++this['$'+name];
              const markFlush = `aurelia-action-${name}-flush-${flushCount}`;
              performance.mark(markFlush);
              const measureFlush = `aurelia-action-${name}-flush-${flushCount-1}`;
              if (flushCount === 1) {
                const markStart = `aurelia-action-${name}-start`;
                performance.measure(measureFlush, markStart, markFlush);
              } else {
                performance.measure(measureFlush, measureFlush, markFlush);
              }
            }
            changeSet.add(this);
          }
        }
      }
      markLifecycle(name) {
        const current = `aurelia-${name}`;
        performance.mark(current);
        const previous = this.previousLifecycle;
        this.previousLifecycle = current;
        if (previous !== null) {
          performance.measure(`${previous}_to_${current}`, previous, current);
        }
        console.log(current);
      }
      markActionStart(name, queued) {
        const markStart = `aurelia-action-${name}-start`;
        performance.mark(markStart);
        this.queuedActions.push(name);
        this['$'+name] = 0;
        //console.log(markStart);
      }
      markActionEnd(name) {
        const markEnd = `aurelia-action-${name}-end`;
        const markStart = `aurelia-action-${name}-start`;
        performance.mark(markEnd);
        const dollarName = '$'+name;
        const flushCount = this[dollarName];
        this[dollarName] = 0;
        if (flushCount > 0) {
          const measureFlush = `aurelia-action-${name}-flush-${flushCount}`;
          performance.measure(measureFlush, measureFlush, markEnd);
        }
        performance.measure(`aurelia-action-${name}`, markStart, markEnd);
        //console.log(markEnd);
      }
    }
    var instrumenter = window.instrumenter = new Instrumenter();
    instrumenter.markLifecycle('page-loaded');
  </script>
</head>

<body>
  <script>
      instrumenter.markLifecycle('body-loaded');
  </script>
  <app></app>
  <script src="dist/bundle.js"></script>
  <script>
      instrumenter.markLifecycle('script-loaded');
  </script>
</body>

</html>
