{"version":3,"file":"index.es6.js","sources":["../src/binding-command.ts","../src/template-binder.ts","../src/template-element-factory.ts","../src/template-compiler.ts","../src/configuration.ts","../src/debugging.ts"],"sourcesContent":["import {\n  BindingCommandResource,\n  BindingSymbol,\n  getTarget,\n  IBindingCommand,\n  PlainAttributeSymbol\n} from '@aurelia/jit';\nimport { IRegistry } from '@aurelia/kernel';\nimport { BindingType, IsBindingBehavior } from '@aurelia/runtime';\nimport {\n  CaptureBindingInstruction,\n  DelegateBindingInstruction,\n  HTMLAttributeInstruction,\n  TriggerBindingInstruction\n} from '@aurelia/runtime-html';\n\nexport interface TriggerBindingCommand extends IBindingCommand {}\nexport class TriggerBindingCommand implements IBindingCommand {\n  public static readonly register: IRegistry['register'];\n  public readonly bindingType: BindingType.TriggerCommand;\n\n  constructor() {\n    this.bindingType = BindingType.TriggerCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): HTMLAttributeInstruction {\n    return new TriggerBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\nBindingCommandResource.define('trigger', TriggerBindingCommand);\n\nexport interface DelegateBindingCommand extends IBindingCommand {}\nexport class DelegateBindingCommand implements IBindingCommand {\n  public static readonly register: IRegistry['register'];\n  public readonly bindingType: BindingType.DelegateCommand;\n\n  constructor() {\n    this.bindingType = BindingType.DelegateCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): HTMLAttributeInstruction {\n    return new DelegateBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\nBindingCommandResource.define('delegate', DelegateBindingCommand);\n\nexport interface CaptureBindingCommand extends IBindingCommand {}\nexport class CaptureBindingCommand implements IBindingCommand {\n  public static readonly register: IRegistry['register'];\n  public readonly bindingType: BindingType.CaptureCommand;\n\n  constructor() {\n    this.bindingType = BindingType.CaptureCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): HTMLAttributeInstruction {\n    return new CaptureBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\nBindingCommandResource.define('capture', CaptureBindingCommand);\n","import {\n  AttrInfo,\n  AttrSyntax,\n  BindableInfo,\n  BindingSymbol,\n  CustomAttributeSymbol,\n  CustomElementSymbol,\n  IAttributeParser,\n  IElementSymbol,\n  IParentNodeSymbol,\n  IResourceAttributeSymbol,\n  ISymbolWithMarker,\n  LetElementSymbol,\n  PlainAttributeSymbol,\n  PlainElementSymbol,\n  ReplacePartSymbol,\n  ResourceModel,\n  SymbolFlags,\n  TemplateControllerSymbol,\n  TextSymbol\n} from '@aurelia/jit';\nimport { PLATFORM, Profiler, Tracer } from '@aurelia/kernel';\nimport {\n  BindingMode,\n  BindingType,\n  IDOM,\n  IExpressionParser\n} from '@aurelia/runtime';\nimport { NodeType } from '@aurelia/runtime-html';\n\nconst slice = Array.prototype.slice;\n\nconst { enter, leave } = Profiler.createTimer('TemplateBinder');\n\nconst invalidSurrogateAttribute = {\n  'id': true,\n  'part': true,\n  'replace-part': true\n};\n\nconst attributesToIgnore = {\n  'as-element': true,\n  'part': true,\n  'replace-part': true\n};\n\nexport class TemplateBinder {\n  public dom: IDOM;\n  public resources: ResourceModel;\n  public attrParser: IAttributeParser;\n  public exprParser: IExpressionParser;\n\n  private surrogate: PlainElementSymbol | null;\n\n  // This is any \"original\" (as in, not a template created for a template controller) element.\n  // It collects all attribute symbols except for template controllers and replace-parts.\n  private manifest: IElementSymbol | null;\n\n  // This is the nearest wrapping custom element.\n  // It only collects replace-parts (and inherently everything that the manifest collects, if they are the same instance)\n  private manifestRoot: CustomElementSymbol | null;\n\n  // This is the nearest wrapping custom element relative to the current manifestRoot (the manifestRoot \"one level up\").\n  // It exclusively collects replace-parts that are placed on the current manifestRoot.\n  private parentManifestRoot: CustomElementSymbol | null;\n\n  private partName: string | null;\n\n  constructor(dom: IDOM, resources: ResourceModel, attrParser: IAttributeParser, exprParser: IExpressionParser) {\n    this.dom = dom;\n    this.resources = resources;\n    this.attrParser = attrParser;\n    this.exprParser = exprParser;\n    this.surrogate = null;\n    this.manifest = null;\n    this.manifestRoot = null;\n    this.parentManifestRoot = null;\n    this.partName = null;\n  }\n\n  public bind(node: HTMLTemplateElement): PlainElementSymbol {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder', 'bind', slice.call(arguments)); }\n    if (Profiler.enabled) { enter(); }\n\n    const surrogateSave = this.surrogate;\n    const parentManifestRootSave = this.parentManifestRoot;\n    const manifestRootSave = this.manifestRoot;\n    const manifestSave = this.manifest;\n\n    const manifest = this.surrogate = this.manifest = new PlainElementSymbol(node);\n\n    const attributes = node.attributes;\n    let i = 0;\n    while (i < attributes.length) {\n      const attr = attributes[i];\n      const attrSyntax = this.attrParser.parse(attr.name, attr.value);\n\n      if (invalidSurrogateAttribute[attrSyntax.target] === true) {\n        if (Profiler.enabled) { leave(); }\n        throw new Error(`Invalid surrogate attribute: ${attrSyntax.target}`);\n        // TODO: use reporter\n      }\n      const attrInfo = this.resources.getAttributeInfo(attrSyntax);\n      if (attrInfo === null) {\n        this.bindPlainAttribute(attrSyntax, attr);\n      } else if (attrInfo.isTemplateController) {\n        if (Profiler.enabled) { leave(); }\n        throw new Error('Cannot have template controller on surrogate element.');\n        // TODO: use reporter\n      } else {\n        this.bindCustomAttribute(attrSyntax, attrInfo);\n      }\n      ++i;\n    }\n\n    this.bindChildNodes(node);\n\n    this.surrogate = surrogateSave;\n    this.parentManifestRoot = parentManifestRootSave;\n    this.manifestRoot = manifestRootSave;\n    this.manifest = manifestSave;\n\n    if (Profiler.enabled) { leave(); }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return manifest;\n  }\n\n  private bindManifest(parentManifest: IElementSymbol, node: HTMLTemplateElement | HTMLElement): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder', 'bindManifest', slice.call(arguments)); }\n\n    switch (node.nodeName) {\n      case 'LET':\n        // let cannot have children and has some different processing rules, so return early\n        this.bindLetElement(parentManifest, node);\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n      case 'SLOT':\n        // slot requires no compilation\n        this.surrogate.hasSlots = true;\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n    }\n\n    // nodes are processed bottom-up so we need to store the manifests before traversing down and\n    // restore them again afterwards\n    const parentManifestRootSave = this.parentManifestRoot;\n    const manifestRootSave = this.manifestRoot;\n    const manifestSave = this.manifest;\n\n    // get the part name to override the name of the compiled definition\n    this.partName = node.getAttribute('part');\n\n    let manifestRoot: CustomElementSymbol;\n    let name = node.getAttribute('as-element');\n    if (name === null) {\n      name = node.nodeName.toLowerCase();\n    }\n    const elementInfo = this.resources.getElementInfo(name);\n    if (elementInfo === null) {\n      // there is no registered custom element with this name\n      this.manifest = new PlainElementSymbol(node);\n    } else {\n      // it's a custom element so we set the manifestRoot as well (for storing replace-parts)\n      this.parentManifestRoot = this.manifestRoot;\n      manifestRoot = this.manifestRoot = this.manifest = new CustomElementSymbol(this.dom, node, elementInfo);\n    }\n\n    // lifting operations done by template controllers and replace-parts effectively unlink the nodes, so start at the bottom\n    this.bindChildNodes(node);\n\n    // the parentManifest will receive either the direct child nodes, or the template controllers / replace-parts\n    // wrapping them\n    this.bindAttributes(node, parentManifest);\n\n    if (manifestRoot !== undefined && manifestRoot.isContainerless) {\n      node.parentNode.replaceChild(manifestRoot.marker as Node, node);\n    } else if (this.manifest.isTarget) {\n      node.classList.add('au');\n    }\n\n    // restore the stored manifests so the attributes are processed on the correct lavel\n    this.parentManifestRoot = parentManifestRootSave;\n    this.manifestRoot = manifestRootSave;\n    this.manifest = manifestSave;\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindLetElement(parentManifest: IElementSymbol, node: HTMLElement): void {\n    const symbol = new LetElementSymbol(this.dom, node);\n    parentManifest.childNodes.push(symbol);\n\n    const attributes = node.attributes;\n    let i = 0;\n    while (i < attributes.length) {\n      const attr = attributes[i];\n      if (attr.name === 'to-view-model') {\n        node.removeAttribute('to-view-model');\n        symbol.toViewModel = true;\n        continue;\n      }\n      const attrSyntax = this.attrParser.parse(attr.name, attr.value);\n      const command = this.resources.getBindingCommand(attrSyntax);\n      const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n      const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n      const to = PLATFORM.camelCase(attrSyntax.target);\n      const info = new BindableInfo(to, BindingMode.toView);\n      symbol.bindings.push(new BindingSymbol(command, info, expr, attrSyntax.rawValue, to));\n\n      ++i;\n    }\n    node.parentNode.replaceChild(symbol.marker as Node, node);\n  }\n\n  private bindAttributes(node: HTMLTemplateElement | HTMLElement, parentManifest: IElementSymbol): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder', 'bindAttributes', slice.call(arguments)); }\n\n    const { parentManifestRoot, manifestRoot, manifest } = this;\n    // This is the top-level symbol for the current depth.\n    // If there are no template controllers or replace-parts, it is always the manifest itself.\n    // If there are template controllers, then this will be the outer-most TemplateControllerSymbol.\n    let manifestProxy: IParentNodeSymbol = manifest;\n\n    const replacePart = this.declareReplacePart(node);\n\n    let previousController: TemplateControllerSymbol;\n    let currentController: TemplateControllerSymbol;\n\n    const attributes = node.attributes;\n    let i = 0;\n    while (i < attributes.length) {\n      const attr = attributes[i];\n      ++i;\n      if (attributesToIgnore[attr.name] === true) {\n        continue;\n      }\n      const attrSyntax = this.attrParser.parse(attr.name, attr.value);\n      const attrInfo = this.resources.getAttributeInfo(attrSyntax);\n\n      if (attrInfo === null) {\n        // it's not a custom attribute but might be a regular bound attribute or interpolation (it might also be nothing)\n        this.bindPlainAttribute(attrSyntax, attr);\n      } else if (attrInfo.isTemplateController) {\n        // the manifest is wrapped by the inner-most template controller (if there are multiple on the same element)\n        // so keep setting manifest.templateController to the latest template controller we find\n        currentController = manifest.templateController = this.declareTemplateController(attrSyntax, attrInfo);\n\n        // the proxy and the manifest are only identical when we're at the first template controller (since the controller\n        // is assigned to the proxy), so this evaluates to true at most once per node\n        if (manifestProxy === manifest) {\n          currentController.template = manifest;\n          manifestProxy = currentController;\n        } else {\n          currentController.templateController = previousController;\n          currentController.template = previousController.template;\n          previousController.template = currentController;\n        }\n        previousController = currentController;\n      } else {\n        // a regular custom attribute\n        this.bindCustomAttribute(attrSyntax, attrInfo);\n      }\n    }\n\n    processTemplateControllers(this.dom, manifestProxy, manifest);\n\n    if (replacePart === null) {\n      // the proxy is either the manifest itself or the outer-most controller; add it directly to the parent\n      parentManifest.childNodes.push(manifestProxy);\n    } else {\n      // there is a replace-part attribute on this node, so add it to the parts collection of the manifestRoot\n      // instead of to the childNodes\n      replacePart.parent = parentManifest;\n      replacePart.template = manifestProxy;\n\n      // if the current manifest is also the manifestRoot, it means the replace-part sits on a custom\n      // element, so add the part to the parent wrapping custom element instead\n      const partOwner = manifest === manifestRoot ? parentManifestRoot : manifestRoot;\n      partOwner.parts.push(replacePart);\n\n      processReplacePart(this.dom, replacePart, manifestProxy);\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindChildNodes(node: HTMLTemplateElement | HTMLElement): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder', 'bindChildNodes', slice.call(arguments)); }\n\n    let childNode: ChildNode;\n    if (node.nodeName === 'TEMPLATE') {\n      childNode = (node as HTMLTemplateElement).content.firstChild;\n    } else {\n      childNode = node.firstChild;\n    }\n\n    let nextChild: ChildNode;\n    while (childNode !== null) {\n      switch (childNode.nodeType) {\n        case NodeType.Element:\n          nextChild = childNode.nextSibling as ChildNode;\n          this.bindManifest(this.manifest, childNode as HTMLElement);\n          childNode = nextChild;\n          break;\n        case NodeType.Text:\n          childNode = this.bindText(childNode as Text).nextSibling as ChildNode;\n          break;\n        case NodeType.CDATASection:\n        case NodeType.ProcessingInstruction:\n        case NodeType.Comment:\n        case NodeType.DocumentType:\n          childNode = childNode.nextSibling as ChildNode;\n          break;\n        case NodeType.Document:\n        case NodeType.DocumentFragment:\n          childNode = childNode.firstChild;\n      }\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindText(node: Text): ChildNode {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder', 'bindText', slice.call(arguments)); }\n    const interpolation = this.exprParser.parse(node.wholeText, BindingType.Interpolation);\n    if (interpolation !== null) {\n      const symbol = new TextSymbol(this.dom, node, interpolation);\n      this.manifest.childNodes.push(symbol);\n      processInterpolationText(symbol);\n    }\n    while (node.nextSibling !== null && node.nextSibling.nodeType === NodeType.Text) {\n      node = node.nextSibling as Text;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return node;\n  }\n\n  private declareTemplateController(attrSyntax: AttrSyntax, attrInfo: AttrInfo): TemplateControllerSymbol {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder', 'declareTemplateController', slice.call(arguments)); }\n\n    let symbol: TemplateControllerSymbol;\n    // dynamicOptions logic here is similar to (and explained in) bindCustomAttribute\n    const command = this.resources.getBindingCommand(attrSyntax);\n    if (command === null && attrInfo.hasDynamicOptions) {\n      symbol = new TemplateControllerSymbol(this.dom, attrSyntax, attrInfo, this.partName);\n      this.partName = null;\n      this.bindMultiAttribute(symbol, attrInfo, attrSyntax.rawValue);\n    } else {\n      symbol = new TemplateControllerSymbol(this.dom, attrSyntax, attrInfo, this.partName);\n      const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n      const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n      symbol.bindings.push(new BindingSymbol(command, attrInfo.bindable, expr, attrSyntax.rawValue, attrSyntax.target));\n      this.partName = null;\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return symbol;\n  }\n\n  private bindCustomAttribute(attrSyntax: AttrSyntax, attrInfo: AttrInfo): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder', 'bindCustomAttribute', slice.call(arguments)); }\n\n    const command = this.resources.getBindingCommand(attrSyntax);\n    let symbol: CustomAttributeSymbol;\n    if (command === null && attrInfo.hasDynamicOptions) {\n      // a dynamicOptions (semicolon separated binding) is only valid without a binding command;\n      // the binding commands must be declared in the dynamicOptions expression itself\n      symbol = new CustomAttributeSymbol(attrSyntax, attrInfo);\n      this.bindMultiAttribute(symbol, attrInfo, attrSyntax.rawValue);\n    } else {\n      // we've either got a command (with or without dynamicOptions, the latter maps to the first bindable),\n      // or a null command but without dynamicOptions (which may be an interpolation or a normal string)\n      symbol = new CustomAttributeSymbol(attrSyntax, attrInfo);\n      const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n      const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n      symbol.bindings.push(new BindingSymbol(command, attrInfo.bindable, expr, attrSyntax.rawValue, attrSyntax.target));\n    }\n    this.manifest.attributes.push(symbol);\n    this.manifest.isTarget = true;\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindMultiAttribute(symbol: IResourceAttributeSymbol, attrInfo: AttrInfo, value: string): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder', 'bindMultiAttribute', slice.call(arguments)); }\n\n    const attributes = parseMultiAttributeBinding(value);\n    let attr: IAttrLike;\n    for (let i = 0, ii = attributes.length; i < ii; ++i) {\n      attr = attributes[i];\n      const attrSyntax = this.attrParser.parse(attr.name, attr.value);\n      const command = this.resources.getBindingCommand(attrSyntax);\n      const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n      const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n      let bindable = attrInfo.bindables[attrSyntax.target];\n      if (bindable === undefined) {\n        // everything in a dynamicOptions expression must be used, so if it's not a bindable then we create one on the spot\n        bindable = attrInfo.bindables[attrSyntax.target] = new BindableInfo(attrSyntax.target, BindingMode.toView);\n      }\n\n      symbol.bindings.push(new BindingSymbol(command, bindable, expr, attrSyntax.rawValue, attrSyntax.target));\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindPlainAttribute(attrSyntax: AttrSyntax, attr: Attr): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder', 'bindPlainAttribute', slice.call(arguments)); }\n\n    if (attrSyntax.rawValue.length === 0) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    const command = this.resources.getBindingCommand(attrSyntax);\n    const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n    const manifest = this.manifest;\n    const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n\n    if (manifest.flags & SymbolFlags.isCustomElement) {\n      const bindable = (manifest as CustomElementSymbol).bindables[attrSyntax.target];\n      if (bindable !== undefined) {\n        // if the attribute name matches a bindable property name, add it regardless of whether it's a command, interpolation, or just a plain string;\n        // the template compiler will translate it to the correct instruction\n        (manifest as CustomElementSymbol).bindings.push(new BindingSymbol(command, bindable, expr, attrSyntax.rawValue, attrSyntax.target));\n        manifest.isTarget = true;\n      } else if (expr !== null || attrSyntax.target === 'ref') {\n        // if it does not map to a bindable, only add it if we were able to parse an expression (either a command or interpolation)\n        manifest.attributes.push(new PlainAttributeSymbol(attrSyntax, command, expr));\n        manifest.isTarget = true;\n      }\n    } else if (expr !== null || attrSyntax.target === 'ref') {\n      // either a binding command, an interpolation, or a ref\n      manifest.attributes.push(new PlainAttributeSymbol(attrSyntax, command, expr));\n      manifest.isTarget = true;\n    } else if (manifest === this.surrogate) {\n      // any attributes, even if they are plain (no command/interpolation etc), should be added if they\n      // are on the surrogate element\n      manifest.attributes.push(new PlainAttributeSymbol(attrSyntax, command, expr));\n    }\n\n    if (command === null && expr !== null) {\n      // if it's an interpolation, clear the attribute value\n      attr.value = '';\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private declareReplacePart(node: HTMLTemplateElement | HTMLElement): ReplacePartSymbol {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder', 'declareReplacePart', slice.call(arguments)); }\n\n    const name = node.getAttribute('replace-part');\n    if (name === null) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return null;\n    }\n    node.removeAttribute('replace-part');\n\n    const symbol = new ReplacePartSymbol(name);\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return symbol;\n  }\n}\n\nfunction processInterpolationText(symbol: TextSymbol): void {\n  const node = symbol.physicalNode as Text;\n  const parentNode = node.parentNode;\n  while (node.nextSibling !== null && node.nextSibling.nodeType === NodeType.Text) {\n    parentNode.removeChild(node.nextSibling);\n  }\n  node.textContent = '';\n  parentNode.insertBefore(symbol.marker as Node, node);\n}\n\n/**\n * A (temporary) standalone function that purely does the DOM processing (lifting) related to template controllers.\n * It's a first refactoring step towards separating DOM parsing/binding from mutations.\n */\nfunction processTemplateControllers(dom: IDOM, manifestProxy: IParentNodeSymbol, manifest: IElementSymbol): void {\n  const manifestNode = manifest.physicalNode as HTMLElement;\n  let current = manifestProxy as TemplateControllerSymbol;\n  let currentTemplate: HTMLTemplateElement;\n  while ((current as IParentNodeSymbol) !== manifest) {\n    if (current.template === manifest) {\n      // the DOM linkage is still in its original state here so we can safely assume the parentNode is non-null\n      manifestNode.parentNode.replaceChild(current.marker as Node, manifestNode);\n\n      // if the manifest is a template element (e.g. <template repeat.for=\"...\">) then we can skip one lift operation\n      // and simply use the template directly, saving a bit of work\n      if (manifestNode.nodeName === 'TEMPLATE') {\n        current.physicalNode = manifestNode as HTMLTemplateElement;\n        // the template could safely stay without affecting anything visible, but let's keep the DOM tidy\n        manifestNode.remove();\n      } else {\n        // the manifest is not a template element so we need to wrap it in one\n        currentTemplate = current.physicalNode = dom.createTemplate() as HTMLTemplateElement;\n        currentTemplate.content.appendChild(manifestNode);\n      }\n    } else {\n      currentTemplate = current.physicalNode = dom.createTemplate() as HTMLTemplateElement;\n      currentTemplate.content.appendChild(current.marker as Node);\n    }\n    manifestNode.removeAttribute(current.syntax.rawName);\n    current = current.template as TemplateControllerSymbol;\n  }\n}\n\nfunction processReplacePart(dom: IDOM, replacePart: ReplacePartSymbol, manifestProxy: IParentNodeSymbol | ISymbolWithMarker): void {\n    let proxyNode: HTMLElement;\n    let currentTemplate: HTMLTemplateElement;\n    if (manifestProxy.flags & SymbolFlags.hasMarker) {\n      proxyNode = (manifestProxy as ISymbolWithMarker).marker as HTMLElement;\n    } else {\n      proxyNode = manifestProxy.physicalNode as HTMLElement;\n    }\n    if (proxyNode.nodeName === 'TEMPLATE') {\n      // if it's a template element, no need to do anything special, just assign it to the replacePart\n      replacePart.physicalNode = proxyNode as HTMLTemplateElement;\n    } else {\n      // otherwise wrap the replace-part in a template\n      currentTemplate = replacePart.physicalNode = dom.createTemplate() as HTMLTemplateElement;\n      currentTemplate.content.appendChild(proxyNode);\n    }\n}\n\ninterface IAttrLike {\n  name: string;\n  value: string;\n}\n\nclass ParserState {\n  public input: string;\n  public index: number;\n  public length: number;\n\n  constructor(input: string) {\n    this.input = input;\n    this.index = 0;\n    this.length = input.length;\n  }\n}\n\nconst fromCharCode = String.fromCharCode;\n\n// TODO: move to expression parser\nfunction parseMultiAttributeBinding(input: string): IAttrLike[] {\n  const attributes: IAttrLike[] = [];\n\n  const state = new ParserState(input);\n  const length = state.length;\n  let name: string;\n  let value: string;\n\n  while (state.index < length) {\n    name = scanAttributeName(state);\n    if (name.length === 0) {\n      return attributes;\n    }\n    value = scanAttributeValue(state);\n    attributes.push({ name, value });\n  }\n\n  return attributes;\n}\n\nfunction scanAttributeName(state: ParserState): string {\n  const start = state.index;\n  const { length, input } = state;\n  while (state.index < length && input.charCodeAt(++state.index) !== Char.Colon);\n\n  return input.slice(start, state.index).trim();\n}\n\nconst enum Char {\n  DoubleQuote    = 0x22,\n  SingleQuote    = 0x27,\n  Slash          = 0x2F,\n  Semicolon      = 0x3B,\n  Colon          = 0x3A\n}\n\nfunction scanAttributeValue(state: ParserState): string {\n  ++state.index;\n  const { length, input } = state;\n  let token = '';\n  let inString = false;\n  let quote = null;\n  let ch = 0;\n  while (state.index < length) {\n    ch = input.charCodeAt(state.index);\n    switch (ch) {\n      case Char.Semicolon:\n        ++state.index;\n        return token.trim();\n      case Char.Slash:\n        ch = input.charCodeAt(++state.index);\n        if (ch === Char.DoubleQuote) {\n          if (inString === false) {\n            inString = true;\n            quote = Char.DoubleQuote;\n          } else if (quote === Char.DoubleQuote) {\n            inString = false;\n            quote = null;\n          }\n        }\n        token += `\\\\${fromCharCode(ch)}`;\n        break;\n      case Char.SingleQuote:\n        if (inString === false) {\n          inString = true;\n          quote = Char.SingleQuote;\n        } else if (quote === Char.SingleQuote) {\n          inString = false;\n          quote = null;\n        }\n        token += '\\'';\n        break;\n      default:\n        token += fromCharCode(ch);\n    }\n    ++state.index;\n  }\n\n  return token.trim();\n}\n","import { DI, IContainer, InjectArray, InterfaceSymbol, IResolver, Profiler, Registration } from '@aurelia/kernel';\nimport { IDOM, INode } from '@aurelia/runtime';\n\n/**\n * Utility that creates a `HTMLTemplateElement` out of string markup or an existing DOM node.\n *\n * It is idempotent in the sense that passing in an existing template element will simply return that template element,\n * so it is always safe to pass in a node without causing unnecessary DOM parsing or template creation.\n */\nexport interface ITemplateElementFactory {\n  /**\n   * Create a `HTMLTemplateElement` from a provided html string.\n   *\n   * @param markup A raw html string that may or may not be wrapped in `<template></template>`\n   */\n  createTemplate(markup: string): INode;\n  /**\n   * Create a `HTMLTemplateElement` from a provided DOM node. If the node is already a template, it\n   * will be returned as-is (and removed from the DOM).\n   *\n   * @param node A DOM node that may or may not be wrapped in `<template></template>`\n   */\n  createTemplate(node: INode): INode;\n  /**\n   * Create a `HTMLTemplateElement` from a provided DOM node or html string.\n   *\n   * @param input A DOM node or raw html string that may or may not be wrapped in `<template></template>`\n   */\n  createTemplate(input: unknown): INode;\n  createTemplate(input: unknown): INode;\n}\n\n// For some reason rollup complains about `DI.createInterface<ITemplateElementFactory>().noDefault()` with this message:\n// \"semantic error TS2742 The inferred type of 'ITemplateElementFactory' cannot be named without a reference to '@aurelia/jit/node_modules/@aurelia/kernel'. This is likely not portable. A type annotation is necessary\"\n// So.. investigate why that happens (or rather, why it *only* happens here and not for the other 50)\nexport const ITemplateElementFactory: InterfaceSymbol<ITemplateElementFactory> = DI.createInterface('ITemplateElementFactory').noDefault();\n\nconst { enter, leave } = Profiler.createTimer('TemplateElementFactory');\n\n/**\n * Default implementation for `ITemplateFactory` for use in an HTML based runtime.\n *\n * @internal\n */\nexport class HTMLTemplateElementFactory implements ITemplateElementFactory {\n  public static readonly inject: InjectArray = [IDOM];\n\n  private readonly dom: IDOM;\n  private template: HTMLTemplateElement;\n\n  constructor(dom: IDOM) {\n    this.dom = dom;\n    this.template = dom.createTemplate() as HTMLTemplateElement;\n  }\n\n  public static register(container: IContainer): IResolver<ITemplateElementFactory> {\n    return Registration.singleton(ITemplateElementFactory, this).register(container);\n  }\n\n  public createTemplate(markup: string): HTMLTemplateElement;\n  public createTemplate(node: Node): HTMLTemplateElement;\n  public createTemplate(input: unknown): HTMLTemplateElement;\n  public createTemplate(input: string | Node): HTMLTemplateElement {\n    if (Profiler.enabled) { enter(); }\n    if (typeof input === 'string') {\n      const template = this.template;\n      template.innerHTML = input;\n      const node = template.content.firstElementChild;\n      // if the input is either not wrapped in a template or there is more than one node,\n      // return the whole template that wraps it/them (and create a new one for the next input)\n      if (node === null || node.nodeName !== 'TEMPLATE' || node.nextElementSibling !== null) {\n        this.template = this.dom.createTemplate() as HTMLTemplateElement;\n        if (Profiler.enabled) { leave(); }\n        return template;\n      }\n      // the node to return is both a template and the only node, so return just the node\n      // and clean up the template for the next input\n      template.content.removeChild(node);\n      if (Profiler.enabled) { leave(); }\n      return node as HTMLTemplateElement;\n    }\n    if (input.nodeName !== 'TEMPLATE') {\n      // if we get one node that is not a template, wrap it in one\n      const template = this.dom.createTemplate() as HTMLTemplateElement;\n      template.content.appendChild(input);\n      if (Profiler.enabled) { leave(); }\n      return template;\n    }\n    // we got a template element, remove it from the DOM if it's present there and don't\n    // do any other processing\n    if (input.parentNode !== null) {\n      input.parentNode.removeChild(input);\n    }\n    if (Profiler.enabled) { leave(); }\n    return input as HTMLTemplateElement;\n  }\n}\n","import {\n  BindingSymbol,\n  CustomAttributeSymbol,\n  CustomElementSymbol,\n  IAttributeParser,\n  IAttributeSymbol,\n  IElementSymbol,\n  INodeSymbol,\n  IParentNodeSymbol,\n  ISymbolWithBindings,\n  LetElementSymbol,\n  PlainAttributeSymbol,\n  PlainElementSymbol,\n  ReplacePartSymbol,\n  ResourceModel,\n  SymbolFlags,\n  TemplateControllerSymbol,\n  TextSymbol\n} from '@aurelia/jit';\nimport { IContainer, InjectArray, IResolver, IResourceDescriptions, PLATFORM, Profiler, Registration } from '@aurelia/kernel';\nimport {\n  HydrateAttributeInstruction,\n  HydrateElementInstruction,\n  HydrateTemplateController,\n  IBuildInstruction,\n  IDOM,\n  IExpressionParser,\n  IInterpolationExpression,\n  ILetBindingInstruction,\n  InterpolationInstruction,\n  IsBindingBehavior,\n  ITargetedInstruction,\n  ITemplateCompiler,\n  ITemplateDefinition,\n  LetBindingInstruction,\n  LetElementInstruction,\n  RefBindingInstruction,\n  SetPropertyInstruction,\n  TemplateDefinition\n} from '@aurelia/runtime';\nimport {\n  HTMLAttributeInstruction,\n  HTMLInstructionRow,\n  SetAttributeInstruction,\n  TextBindingInstruction\n} from '@aurelia/runtime-html';\nimport { TemplateBinder } from './template-binder';\nimport { ITemplateElementFactory } from './template-element-factory';\n\nconst buildNotRequired: IBuildInstruction = Object.freeze({\n  required: false,\n  compiler: 'default'\n});\n\nconst { enter, leave } = Profiler.createTimer('TemplateCompiler');\n\n/**\n * Default (runtime-agnostic) implementation for `ITemplateCompiler`.\n *\n * @internal\n */\nexport class TemplateCompiler implements ITemplateCompiler {\n  public static readonly inject: InjectArray = [ITemplateElementFactory, IAttributeParser, IExpressionParser];\n\n  private readonly factory: ITemplateElementFactory;\n  private readonly attrParser: IAttributeParser;\n  private readonly exprParser: IExpressionParser;\n\n  /**\n   * The instructions array for the currently instruction-collecting `ITemplateDefinition`\n   */\n  private instructionRows: HTMLInstructionRow[];\n\n  public get name(): string {\n    return 'default';\n  }\n\n  constructor(factory: ITemplateElementFactory, attrParser: IAttributeParser, exprParser: IExpressionParser) {\n    this.factory = factory;\n    this.attrParser = attrParser;\n    this.exprParser = exprParser;\n    this.instructionRows = null;\n  }\n\n  public static register(container: IContainer): IResolver<ITemplateCompiler> {\n    return Registration.singleton(ITemplateCompiler, this).register(container);\n  }\n\n  public compile(dom: IDOM, definition: ITemplateDefinition, descriptions: IResourceDescriptions): TemplateDefinition {\n    if (Profiler.enabled) { enter(); }\n    const binder = new TemplateBinder(dom, new ResourceModel(descriptions), this.attrParser, this.exprParser);\n    const template = definition.template = this.factory.createTemplate(definition.template) as HTMLTemplateElement;\n    const surrogate = binder.bind(template);\n    if (definition.instructions === undefined || definition.instructions === PLATFORM.emptyArray) {\n      definition.instructions = [];\n    }\n    if (surrogate.hasSlots === true) {\n      definition.hasSlots = true;\n    }\n\n    this.instructionRows = definition.instructions as HTMLInstructionRow[];\n\n    const attributes = surrogate.attributes;\n    const len = attributes.length;\n    if (len > 0) {\n      let surrogates: ITargetedInstruction[];\n      if (definition.surrogates === undefined || definition.surrogates === PLATFORM.emptyArray) {\n        definition.surrogates = Array(len);\n      }\n      surrogates = definition.surrogates;\n      for (let i = 0; i < len; ++i) {\n        surrogates[i] = this.compileAttribute(attributes[i]);\n      }\n    }\n\n    this.compileChildNodes(surrogate);\n\n    this.instructionRows = null;\n\n    if (Profiler.enabled) { leave(); }\n    return definition as TemplateDefinition;\n  }\n\n  private compileChildNodes(parent: IElementSymbol): void {\n    if (parent.flags & SymbolFlags.hasChildNodes) {\n      const { childNodes } = parent;\n      let childNode: INodeSymbol;\n      const ii = childNodes.length;\n      for (let i = 0; i < ii; ++i) {\n        childNode = childNodes[i];\n        if (childNode.flags & SymbolFlags.isText) {\n          this.instructionRows.push([new TextBindingInstruction((childNode as TextSymbol).interpolation)]);\n        } else if (childNode.flags & SymbolFlags.isLetElement) {\n          const bindings = (childNode as LetElementSymbol).bindings;\n          const instructions: ILetBindingInstruction[] = [];\n          let binding: BindingSymbol;\n          const jj = bindings.length;\n          for (let j = 0; j < jj; ++j) {\n            binding = bindings[j];\n            instructions[j] = new LetBindingInstruction(binding.expression as IsBindingBehavior, binding.target);\n          }\n          this.instructionRows.push([new LetElementInstruction(instructions, (childNode as LetElementSymbol).toViewModel)]);\n        } else {\n          this.compileParentNode(childNode as IParentNodeSymbol);\n        }\n      }\n    }\n  }\n\n  private compileCustomElement(symbol: CustomElementSymbol): void {\n    // offset 1 to leave a spot for the hydrate instruction so we don't need to create 2 arrays with a spread etc\n    const instructionRow = this.compileAttributes(symbol, 1) as HTMLInstructionRow;\n    instructionRow[0] = new HydrateElementInstruction(\n      symbol.res,\n      this.compileBindings(symbol),\n      this.compileParts(symbol)\n    );\n\n    this.instructionRows.push(instructionRow);\n  }\n\n  private compilePlainElement(symbol: PlainElementSymbol): void {\n    const attributes = this.compileAttributes(symbol, 0);\n    if (attributes.length > 0) {\n      this.instructionRows.push(attributes as HTMLInstructionRow);\n    }\n    this.compileChildNodes(symbol);\n  }\n\n  private compileParentNode(symbol: IParentNodeSymbol): void {\n    switch (symbol.flags & SymbolFlags.type) {\n      case SymbolFlags.isCustomElement:\n        this.compileCustomElement(symbol as CustomElementSymbol);\n        break;\n      case SymbolFlags.isPlainElement:\n        this.compilePlainElement(symbol as PlainElementSymbol);\n        break;\n      case SymbolFlags.isTemplateController:\n        this.compileTemplateController(symbol as TemplateControllerSymbol);\n    }\n  }\n\n  private compileTemplateController(symbol: TemplateControllerSymbol): void {\n    const bindings = this.compileBindings(symbol);\n    const instructionRowsSave = this.instructionRows;\n    const controllerInstructions = this.instructionRows = [];\n    this.compileParentNode(symbol.template);\n    this.instructionRows = instructionRowsSave;\n\n    const def = {\n      name: symbol.partName === null ? symbol.res : symbol.partName,\n      template: symbol.physicalNode,\n      instructions: controllerInstructions,\n      build: buildNotRequired\n    };\n    this.instructionRows.push([new HydrateTemplateController(def, symbol.res, bindings, symbol.res === 'else')]);\n  }\n\n  private compileBindings(symbol: ISymbolWithBindings): HTMLAttributeInstruction[] {\n    let bindingInstructions: HTMLAttributeInstruction[];\n    if (symbol.flags & SymbolFlags.hasBindings) {\n      // either a custom element with bindings, a custom attribute / template controller with dynamic options,\n      // or a single value custom attribute binding\n      const { bindings } = symbol;\n      const len = bindings.length;\n      bindingInstructions = Array(len);\n      let i = 0;\n      for (; i < len; ++i) {\n        bindingInstructions[i] = this.compileBinding(bindings[i]);\n      }\n    } else {\n      bindingInstructions = PLATFORM.emptyArray as HTMLAttributeInstruction[];\n    }\n    return bindingInstructions;\n  }\n\n  private compileBinding(symbol: BindingSymbol): HTMLAttributeInstruction {\n    if (symbol.command === null) {\n      // either an interpolation or a normal string value assigned to an element or attribute binding\n      if (symbol.expression === null) {\n        // the template binder already filtered out non-bindables, so we know we need a setProperty here\n        return new SetPropertyInstruction(symbol.rawValue, symbol.bindable.propName);\n      } else {\n        // either an element binding interpolation or a dynamic options attribute binding interpolation\n        return new InterpolationInstruction(symbol.expression as IInterpolationExpression, symbol.bindable.propName);\n      }\n    } else {\n      // either an element binding command, dynamic options attribute binding command,\n      // or custom attribute / template controller (single value) binding command\n      return symbol.command.compile(symbol) as HTMLAttributeInstruction;\n    }\n  }\n\n  private compileAttributes(symbol: IElementSymbol, offset: number): HTMLAttributeInstruction[] {\n    let attributeInstructions: HTMLAttributeInstruction[];\n    if (symbol.flags & SymbolFlags.hasAttributes) {\n      // any attributes on a custom element (which are not bindables) or a plain element\n      const { attributes } = symbol;\n      const len = attributes.length;\n      attributeInstructions = Array(offset + len);\n      for (let i = 0; i < len; ++i) {\n        attributeInstructions[i + offset] = this.compileAttribute(attributes[i]);\n      }\n    } else if (offset > 0) {\n      attributeInstructions = Array(offset);\n    } else {\n      attributeInstructions = PLATFORM.emptyArray as HTMLAttributeInstruction[];\n    }\n    return attributeInstructions;\n  }\n\n  private compileCustomAttribute(symbol: CustomAttributeSymbol): HTMLAttributeInstruction {\n    // a normal custom attribute (not template controller)\n    const bindings = this.compileBindings(symbol);\n    return new HydrateAttributeInstruction(symbol.res, bindings);\n  }\n\n  private compilePlainAttribute(symbol: PlainAttributeSymbol): HTMLAttributeInstruction {\n    if (symbol.command === null) {\n      if (symbol.expression === null) {\n        // a plain attribute on a surrogate\n        return new SetAttributeInstruction(symbol.syntax.rawValue, symbol.syntax.target);\n      } else {\n        // a plain attribute with an interpolation\n        return new InterpolationInstruction(symbol.expression as IInterpolationExpression, symbol.syntax.target);\n      }\n    } else {\n      // a plain attribute with a binding command\n      return symbol.command.compile(symbol) as HTMLAttributeInstruction;\n    }\n  }\n\n  private compileAttribute(symbol: IAttributeSymbol): HTMLAttributeInstruction {\n    if (symbol.syntax.target === 'ref') {\n      return new RefBindingInstruction(symbol.syntax.rawValue);\n    }\n    // any attribute on a custom element (which is not a bindable) or a plain element\n    if (symbol.flags & SymbolFlags.isCustomAttribute) {\n      return this.compileCustomAttribute(symbol as CustomAttributeSymbol);\n    } else {\n      return this.compilePlainAttribute(symbol as PlainAttributeSymbol);\n    }\n  }\n\n  private compileParts(symbol: CustomElementSymbol): Record<string, ITemplateDefinition> {\n    let parts: Record<string, ITemplateDefinition>;\n    if (symbol.flags & SymbolFlags.hasParts) {\n      parts = {};\n      const replaceParts = symbol.parts;\n      const ii = replaceParts.length;\n      let instructionRowsSave: HTMLInstructionRow[];\n      let partInstructions: HTMLInstructionRow[];\n      let replacePart: ReplacePartSymbol;\n      for (let i = 0; i < ii; ++i) {\n        replacePart = replaceParts[i];\n        instructionRowsSave = this.instructionRows;\n        partInstructions = this.instructionRows = [];\n        this.compileParentNode(replacePart.template);\n        parts[replacePart.name] = {\n          name: replacePart.name,\n          template: replacePart.physicalNode,\n          instructions: partInstructions,\n          build: buildNotRequired\n        };\n        this.instructionRows = instructionRowsSave;\n      }\n    } else {\n      parts = PLATFORM.emptyObject;\n    }\n    return parts;\n  }\n}\n","import {\n  DefaultBindingLanguage as JitDefaultBindingLanguage,\n  DefaultBindingSyntax as JitDefaultBindingSyntax,\n  DefaultComponents as JitDefaultComponents\n} from '@aurelia/jit';\nimport { DI, IContainer, IRegistry } from '@aurelia/kernel';\nimport { BasicConfiguration as RuntimeHtmlBasicConfiguration } from '@aurelia/runtime-html';\nimport {\n  CaptureBindingCommand,\n  DelegateBindingCommand,\n  TriggerBindingCommand\n} from './binding-command';\nimport { TemplateCompiler } from './template-compiler';\nimport { HTMLTemplateElementFactory } from './template-element-factory';\n\nexport const ITemplateCompilerRegistration = TemplateCompiler as IRegistry;\nexport const ITemplateElementFactoryRegistration = HTMLTemplateElementFactory as IRegistry;\n\n/**\n * Default HTML-specific (but environment-agnostic) implementations for the following interfaces:\n * - `ITemplateCompiler`\n * - `ITemplateElementFactory`\n */\nexport const DefaultComponents = [\n  ITemplateCompilerRegistration,\n  ITemplateElementFactoryRegistration\n];\n\nexport const TriggerBindingCommandRegistration = TriggerBindingCommand as IRegistry;\nexport const DelegateBindingCommandRegistration = DelegateBindingCommand as IRegistry;\nexport const CaptureBindingCommandRegistration = CaptureBindingCommand as IRegistry;\n\n/**\n * Default HTML-specific (but environment-agnostic) binding commands:\n * - Event listeners: `.trigger`, `.delegate`, `.capture`\n */\nexport const DefaultBindingLanguage = [\n  TriggerBindingCommandRegistration,\n  DelegateBindingCommandRegistration,\n  CaptureBindingCommandRegistration\n];\n\n/**\n * A DI configuration object containing html-specific (but environment-agnostic) registrations:\n * - `BasicConfiguration` from `@aurelia/runtime-html`\n * - `DefaultComponents` from `@aurelia/jit`\n * - `DefaultBindingSyntax` from `@aurelia/jit`\n * - `DefaultBindingLanguage` from `@aurelia/jit`\n * - `DefaultComponents`\n * - `DefaultBindingLanguage`\n */\nexport const BasicConfiguration = {\n  /**\n   * Apply this configuration to the provided container.\n   */\n  register(container: IContainer): IContainer {\n    return RuntimeHtmlBasicConfiguration\n      .register(container)\n      .register(\n        ...JitDefaultComponents,\n        ...JitDefaultBindingSyntax,\n        ...JitDefaultBindingLanguage,\n        ...DefaultComponents,\n        ...DefaultBindingLanguage\n      );\n  },\n  /**\n   * Create a new container with this configuration applied to it.\n   */\n  createContainer(): IContainer {\n    return this.register(DI.createContainer());\n  }\n};\n","import { ITemplateDefinition, TargetedInstructionType } from '@aurelia/runtime';\nimport { HTMLTargetedInstruction, HTMLTargetedInstructionType, NodeType } from '@aurelia/runtime-html';\n\nexport function stringifyDOM(node: Node, depth: number): string {\n  const indent = ' '.repeat(depth);\n  let output = indent;\n  output += `Node: ${node.nodeName}`;\n  if (node.nodeType === NodeType.Text) {\n    output += ` \"${node.textContent}\"`;\n  }\n  if (node.nodeType === NodeType.Element) {\n    let i = 0;\n    let attr;\n    const attributes = (node as HTMLElement).attributes;\n    const len = attributes.length;\n    for (; i < len; ++i) {\n      attr = attributes[i];\n      output += ` ${attr.name}=${attr.value}`;\n    }\n  }\n  output += '\\n';\n  if (node.nodeType === NodeType.Element) {\n    let i = 0;\n    let childNodes = node.childNodes;\n    let len = childNodes.length;\n    for (; i < len; ++i) {\n      output += stringifyDOM(childNodes[i], depth + 1);\n    }\n    if (node.nodeName === 'TEMPLATE') {\n      i = 0;\n      childNodes = (node as HTMLTemplateElement).content.childNodes;\n      len = childNodes.length;\n      for (; i < len; ++i) {\n        output += stringifyDOM(childNodes[i], depth + 1);\n      }\n    }\n  }\n  return output;\n}\n\nexport function stringifyInstructions(instruction: HTMLTargetedInstruction, depth: number): string {\n  const indent = ' '.repeat(depth);\n  let output = indent;\n  switch (instruction.type) {\n    case HTMLTargetedInstructionType.textBinding:\n      output += 'textBinding\\n';\n      break;\n    case TargetedInstructionType.callBinding:\n      output += 'callBinding\\n';\n      break;\n    case TargetedInstructionType.iteratorBinding:\n      output += 'iteratorBinding\\n';\n      break;\n    case HTMLTargetedInstructionType.listenerBinding:\n      output += 'listenerBinding\\n';\n      break;\n    case TargetedInstructionType.propertyBinding:\n      output += 'propertyBinding\\n';\n      break;\n    case TargetedInstructionType.refBinding:\n      output += 'refBinding\\n';\n      break;\n    case HTMLTargetedInstructionType.stylePropertyBinding:\n      output += 'stylePropertyBinding\\n';\n      break;\n    case TargetedInstructionType.setProperty:\n      output += 'setProperty\\n';\n      break;\n    case HTMLTargetedInstructionType.setAttribute:\n      output += 'setAttribute\\n';\n      break;\n    case TargetedInstructionType.interpolation:\n      output += 'interpolation\\n';\n      break;\n    case TargetedInstructionType.hydrateLetElement:\n      output += 'hydrateLetElement\\n';\n      instruction.instructions.forEach(i => {\n        output += stringifyInstructions(i, depth + 1);\n      });\n      break;\n    case TargetedInstructionType.hydrateAttribute:\n      output += `hydrateAttribute: ${instruction.res}\\n`;\n      instruction.instructions.forEach(i => {\n        output += stringifyInstructions(i as HTMLTargetedInstruction, depth + 1);\n      });\n      break;\n    case TargetedInstructionType.hydrateElement:\n      output += `hydrateElement: ${instruction.res}\\n`;\n      instruction.instructions.forEach(i => {\n        output += stringifyInstructions(i as HTMLTargetedInstruction, depth + 1);\n      });\n      break;\n    case TargetedInstructionType.hydrateTemplateController:\n      output += `hydrateTemplateController: ${instruction.res}\\n`;\n      output += stringifyTemplateDefinition(instruction.def, depth + 1);\n      instruction.instructions.forEach(i => {\n        output += stringifyInstructions(i as HTMLTargetedInstruction, depth + 1);\n      });\n  }\n  return output;\n}\n\nexport function stringifyTemplateDefinition(def: ITemplateDefinition, depth: number): string {\n  const indent = ' '.repeat(depth);\n  let output = indent;\n\n  output += `TemplateDefinition: ${def.name}\\n`;\n  output += stringifyDOM(def.template as Node, depth + 1);\n  output += `${indent} Instructions:\\n`;\n  def.instructions.forEach(row => {\n    output += `${indent}  Row:\\n`;\n    row.forEach(i => {\n      output += stringifyInstructions(i as HTMLTargetedInstruction, depth + 3);\n    });\n  });\n\n  return output;\n}\n"],"names":["enter","leave","DefaultComponents","DefaultBindingLanguage","BasicConfiguration","RuntimeHtmlBasicConfiguration","JitDefaultComponents","JitDefaultBindingSyntax","JitDefaultBindingLanguage"],"mappings":"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"}