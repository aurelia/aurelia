{"version":3,"file":"index.iife.js","sources":["../src/binding-command.ts","../src/template-binder.ts","../src/template-element-factory.ts","../src/template-compiler.ts","../src/configuration.ts","../src/debugging.ts"],"sourcesContent":["import {\n  BindingCommandResource,\n  BindingSymbol,\n  getTarget,\n  IBindingCommand,\n  PlainAttributeSymbol\n} from '@aurelia/jit';\nimport { IRegistry } from '@aurelia/kernel';\nimport { BindingType, IsBindingBehavior } from '@aurelia/runtime';\nimport {\n  CaptureBindingInstruction,\n  DelegateBindingInstruction,\n  HTMLAttributeInstruction,\n  TriggerBindingInstruction\n} from '@aurelia/runtime-html';\n\nexport interface TriggerBindingCommand extends IBindingCommand {}\nexport class TriggerBindingCommand implements IBindingCommand {\n  public static readonly register: IRegistry['register'];\n  public readonly bindingType: BindingType.TriggerCommand;\n\n  constructor() {\n    this.bindingType = BindingType.TriggerCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): HTMLAttributeInstruction {\n    return new TriggerBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\nBindingCommandResource.define('trigger', TriggerBindingCommand);\n\nexport interface DelegateBindingCommand extends IBindingCommand {}\nexport class DelegateBindingCommand implements IBindingCommand {\n  public static readonly register: IRegistry['register'];\n  public readonly bindingType: BindingType.DelegateCommand;\n\n  constructor() {\n    this.bindingType = BindingType.DelegateCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): HTMLAttributeInstruction {\n    return new DelegateBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\nBindingCommandResource.define('delegate', DelegateBindingCommand);\n\nexport interface CaptureBindingCommand extends IBindingCommand {}\nexport class CaptureBindingCommand implements IBindingCommand {\n  public static readonly register: IRegistry['register'];\n  public readonly bindingType: BindingType.CaptureCommand;\n\n  constructor() {\n    this.bindingType = BindingType.CaptureCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): HTMLAttributeInstruction {\n    return new CaptureBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\nBindingCommandResource.define('capture', CaptureBindingCommand);\n","import {\n  AttrInfo,\n  AttrSyntax,\n  BindableInfo,\n  BindingSymbol,\n  CustomAttributeSymbol,\n  CustomElementSymbol,\n  IAttributeParser,\n  IElementSymbol,\n  IParentNodeSymbol,\n  IResourceAttributeSymbol,\n  ISymbolWithMarker,\n  LetElementSymbol,\n  PlainAttributeSymbol,\n  PlainElementSymbol,\n  ReplacePartSymbol,\n  ResourceModel,\n  SymbolFlags,\n  TemplateControllerSymbol,\n  TextSymbol\n} from '@aurelia/jit';\nimport { PLATFORM, Profiler, Tracer } from '@aurelia/kernel';\nimport {\n  BindingMode,\n  BindingType,\n  IDOM,\n  IExpressionParser\n} from '@aurelia/runtime';\nimport { NodeType } from '@aurelia/runtime-html';\n\nconst slice = Array.prototype.slice;\n\nconst { enter, leave } = Profiler.createTimer('TemplateBinder');\n\nconst invalidSurrogateAttribute = {\n  'id': true,\n  'part': true,\n  'replace-part': true\n};\n\nconst attributesToIgnore = {\n  'as-element': true,\n  'part': true,\n  'replace-part': true\n};\n\nexport class TemplateBinder {\n  public dom: IDOM;\n  public resources: ResourceModel;\n  public attrParser: IAttributeParser;\n  public exprParser: IExpressionParser;\n\n  private surrogate: PlainElementSymbol | null;\n\n  // This is any \"original\" (as in, not a template created for a template controller) element.\n  // It collects all attribute symbols except for template controllers and replace-parts.\n  private manifest: IElementSymbol | null;\n\n  // This is the nearest wrapping custom element.\n  // It only collects replace-parts (and inherently everything that the manifest collects, if they are the same instance)\n  private manifestRoot: CustomElementSymbol | null;\n\n  // This is the nearest wrapping custom element relative to the current manifestRoot (the manifestRoot \"one level up\").\n  // It exclusively collects replace-parts that are placed on the current manifestRoot.\n  private parentManifestRoot: CustomElementSymbol | null;\n\n  private partName: string | null;\n\n  constructor(dom: IDOM, resources: ResourceModel, attrParser: IAttributeParser, exprParser: IExpressionParser) {\n    this.dom = dom;\n    this.resources = resources;\n    this.attrParser = attrParser;\n    this.exprParser = exprParser;\n    this.surrogate = null;\n    this.manifest = null;\n    this.manifestRoot = null;\n    this.parentManifestRoot = null;\n    this.partName = null;\n  }\n\n  public bind(node: HTMLTemplateElement): PlainElementSymbol {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bind', slice.call(arguments)); }\n    if (Profiler.enabled) { enter(); }\n\n    const surrogateSave = this.surrogate;\n    const parentManifestRootSave = this.parentManifestRoot;\n    const manifestRootSave = this.manifestRoot;\n    const manifestSave = this.manifest;\n\n    const manifest = this.surrogate = this.manifest = new PlainElementSymbol(node);\n\n    const attributes = node.attributes;\n    let i = 0;\n    while (i < attributes.length) {\n      const attr = attributes[i];\n      const attrSyntax = this.attrParser.parse(attr.name, attr.value);\n\n      if (invalidSurrogateAttribute[attrSyntax.target] === true) {\n        if (Profiler.enabled) { leave(); }\n        throw new Error(`Invalid surrogate attribute: ${attrSyntax.target}`);\n        // TODO: use reporter\n      }\n      const attrInfo = this.resources.getAttributeInfo(attrSyntax);\n      if (attrInfo === null) {\n        this.bindPlainAttribute(attrSyntax);\n      } else if (attrInfo.isTemplateController) {\n        if (Profiler.enabled) { leave(); }\n        throw new Error('Cannot have template controller on surrogate element.');\n        // TODO: use reporter\n      } else {\n        this.bindCustomAttribute(attrSyntax, attrInfo);\n      }\n      ++i;\n    }\n\n    this.bindChildNodes(node);\n\n    this.surrogate = surrogateSave;\n    this.parentManifestRoot = parentManifestRootSave;\n    this.manifestRoot = manifestRootSave;\n    this.manifest = manifestSave;\n\n    if (Profiler.enabled) { leave(); }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return manifest;\n  }\n\n  private bindManifest(parentManifest: IElementSymbol, node: HTMLTemplateElement | HTMLElement): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindManifest', slice.call(arguments)); }\n\n    switch (node.nodeName) {\n      case 'LET':\n        // let cannot have children and has some different processing rules, so return early\n        this.bindLetElement(parentManifest, node);\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n      case 'SLOT':\n        // slot requires no compilation\n        this.surrogate.hasSlots = true;\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n    }\n\n    // nodes are processed bottom-up so we need to store the manifests before traversing down and\n    // restore them again afterwards\n    const parentManifestRootSave = this.parentManifestRoot;\n    const manifestRootSave = this.manifestRoot;\n    const manifestSave = this.manifest;\n\n    // get the part name to override the name of the compiled definition\n    this.partName = node.getAttribute('part');\n\n    let manifestRoot: CustomElementSymbol;\n    let name = node.getAttribute('as-element');\n    if (name === null) {\n      name = node.nodeName.toLowerCase();\n    }\n    const elementInfo = this.resources.getElementInfo(name);\n    if (elementInfo === null) {\n      // there is no registered custom element with this name\n      this.manifest = new PlainElementSymbol(node);\n    } else {\n      // it's a custom element so we set the manifestRoot as well (for storing replace-parts)\n      this.parentManifestRoot = this.manifestRoot;\n      manifestRoot = this.manifestRoot = this.manifest = new CustomElementSymbol(this.dom, node, elementInfo);\n    }\n\n    // lifting operations done by template controllers and replace-parts effectively unlink the nodes, so start at the bottom\n    this.bindChildNodes(node);\n\n    // the parentManifest will receive either the direct child nodes, or the template controllers / replace-parts\n    // wrapping them\n    this.bindAttributes(node, parentManifest);\n\n    if (manifestRoot !== undefined && manifestRoot.isContainerless) {\n      node.parentNode.replaceChild(manifestRoot.marker as Node, node);\n    } else if (this.manifest.isTarget) {\n      node.classList.add('au');\n    }\n\n    // restore the stored manifests so the attributes are processed on the correct lavel\n    this.parentManifestRoot = parentManifestRootSave;\n    this.manifestRoot = manifestRootSave;\n    this.manifest = manifestSave;\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindLetElement(parentManifest: IElementSymbol, node: HTMLElement): void {\n    const symbol = new LetElementSymbol(this.dom, node);\n    parentManifest.childNodes.push(symbol);\n\n    const attributes = node.attributes;\n    let i = 0;\n    while (i < attributes.length) {\n      const attr = attributes[i];\n      if (attr.name === 'to-view-model') {\n        node.removeAttribute('to-view-model');\n        symbol.toViewModel = true;\n        continue;\n      }\n      const attrSyntax = this.attrParser.parse(attr.name, attr.value);\n      const command = this.resources.getBindingCommand(attrSyntax);\n      const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n      const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n      const to = PLATFORM.camelCase(attrSyntax.target);\n      const info = new BindableInfo(to, BindingMode.toView);\n      symbol.bindings.push(new BindingSymbol(command, info, expr, attrSyntax.rawValue, to));\n\n      ++i;\n    }\n    node.parentNode.replaceChild(symbol.marker as Node, node);\n  }\n\n  private bindAttributes(node: HTMLTemplateElement | HTMLElement, parentManifest: IElementSymbol): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindAttributes', slice.call(arguments)); }\n\n    const { parentManifestRoot, manifestRoot, manifest } = this;\n    // This is the top-level symbol for the current depth.\n    // If there are no template controllers or replace-parts, it is always the manifest itself.\n    // If there are template controllers, then this will be the outer-most TemplateControllerSymbol.\n    let manifestProxy: IParentNodeSymbol = manifest;\n\n    const replacePart = this.declareReplacePart(node);\n\n    let previousController: TemplateControllerSymbol;\n    let currentController: TemplateControllerSymbol;\n\n    const attributes = node.attributes;\n    let i = 0;\n    while (i < attributes.length) {\n      const attr = attributes[i];\n      ++i;\n      if (attributesToIgnore[attr.name] === true) {\n        continue;\n      }\n      const attrSyntax = this.attrParser.parse(attr.name, attr.value);\n      const attrInfo = this.resources.getAttributeInfo(attrSyntax);\n\n      if (attrInfo === null) {\n        // it's not a custom attribute but might be a regular bound attribute or interpolation (it might also be nothing)\n        this.bindPlainAttribute(attrSyntax);\n      } else if (attrInfo.isTemplateController) {\n        // the manifest is wrapped by the inner-most template controller (if there are multiple on the same element)\n        // so keep setting manifest.templateController to the latest template controller we find\n        currentController = manifest.templateController = this.declareTemplateController(attrSyntax, attrInfo);\n\n        // the proxy and the manifest are only identical when we're at the first template controller (since the controller\n        // is assigned to the proxy), so this evaluates to true at most once per node\n        if (manifestProxy === manifest) {\n          currentController.template = manifest;\n          manifestProxy = currentController;\n        } else {\n          currentController.templateController = previousController;\n          currentController.template = previousController.template;\n          previousController.template = currentController;\n        }\n        previousController = currentController;\n      } else {\n        // a regular custom attribute\n        this.bindCustomAttribute(attrSyntax, attrInfo);\n      }\n    }\n\n    processTemplateControllers(this.dom, manifestProxy, manifest);\n\n    if (replacePart === null) {\n      // the proxy is either the manifest itself or the outer-most controller; add it directly to the parent\n      parentManifest.childNodes.push(manifestProxy);\n    } else {\n      // there is a replace-part attribute on this node, so add it to the parts collection of the manifestRoot\n      // instead of to the childNodes\n      replacePart.parent = parentManifest;\n      replacePart.template = manifestProxy;\n\n      // if the current manifest is also the manifestRoot, it means the replace-part sits on a custom\n      // element, so add the part to the parent wrapping custom element instead\n      const partOwner = manifest === manifestRoot ? parentManifestRoot : manifestRoot;\n      partOwner.parts.push(replacePart);\n\n      processReplacePart(this.dom, replacePart, manifestProxy);\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindChildNodes(node: HTMLTemplateElement | HTMLElement): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindChildNodes', slice.call(arguments)); }\n\n    let childNode: ChildNode;\n    if (node.nodeName === 'TEMPLATE') {\n      childNode = (node as HTMLTemplateElement).content.firstChild;\n    } else {\n      childNode = node.firstChild;\n    }\n\n    let nextChild: ChildNode;\n    while (childNode !== null) {\n      switch (childNode.nodeType) {\n        case NodeType.Element:\n          nextChild = childNode.nextSibling as ChildNode;\n          this.bindManifest(this.manifest, childNode as HTMLElement);\n          childNode = nextChild;\n          break;\n        case NodeType.Text:\n          childNode = this.bindText(childNode as Text).nextSibling as ChildNode;\n          break;\n        case NodeType.CDATASection:\n        case NodeType.ProcessingInstruction:\n        case NodeType.Comment:\n        case NodeType.DocumentType:\n          childNode = childNode.nextSibling as ChildNode;\n          break;\n        case NodeType.Document:\n        case NodeType.DocumentFragment:\n          childNode = childNode.firstChild;\n      }\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindText(node: Text): ChildNode {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindText', slice.call(arguments)); }\n    const interpolation = this.exprParser.parse(node.wholeText, BindingType.Interpolation);\n    if (interpolation !== null) {\n      const symbol = new TextSymbol(this.dom, node, interpolation);\n      this.manifest.childNodes.push(symbol);\n      processInterpolationText(symbol);\n    }\n    while (node.nextSibling !== null && node.nextSibling.nodeType === NodeType.Text) {\n      node = node.nextSibling as Text;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return node;\n  }\n\n  private declareTemplateController(attrSyntax: AttrSyntax, attrInfo: AttrInfo): TemplateControllerSymbol {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.declareTemplateController', slice.call(arguments)); }\n\n    let symbol: TemplateControllerSymbol;\n    // dynamicOptions logic here is similar to (and explained in) bindCustomAttribute\n    const command = this.resources.getBindingCommand(attrSyntax);\n    if (command === null && attrInfo.hasDynamicOptions) {\n      symbol = new TemplateControllerSymbol(this.dom, attrSyntax, attrInfo, this.partName);\n      this.partName = null;\n      this.bindMultiAttribute(symbol, attrInfo, attrSyntax.rawValue);\n    } else {\n      symbol = new TemplateControllerSymbol(this.dom, attrSyntax, attrInfo, this.partName);\n      const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n      const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n      symbol.bindings.push(new BindingSymbol(command, attrInfo.bindable, expr, attrSyntax.rawValue, attrSyntax.target));\n      this.partName = null;\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return symbol;\n  }\n\n  private bindCustomAttribute(attrSyntax: AttrSyntax, attrInfo: AttrInfo): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindCustomAttribute', slice.call(arguments)); }\n\n    const command = this.resources.getBindingCommand(attrSyntax);\n    let symbol: CustomAttributeSymbol;\n    if (command === null && attrInfo.hasDynamicOptions) {\n      // a dynamicOptions (semicolon separated binding) is only valid without a binding command;\n      // the binding commands must be declared in the dynamicOptions expression itself\n      symbol = new CustomAttributeSymbol(attrSyntax, attrInfo);\n      this.bindMultiAttribute(symbol, attrInfo, attrSyntax.rawValue);\n    } else {\n      // we've either got a command (with or without dynamicOptions, the latter maps to the first bindable),\n      // or a null command but without dynamicOptions (which may be an interpolation or a normal string)\n      symbol = new CustomAttributeSymbol(attrSyntax, attrInfo);\n      const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n      const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n      symbol.bindings.push(new BindingSymbol(command, attrInfo.bindable, expr, attrSyntax.rawValue, attrSyntax.target));\n    }\n    this.manifest.attributes.push(symbol);\n    this.manifest.isTarget = true;\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindMultiAttribute(symbol: IResourceAttributeSymbol, attrInfo: AttrInfo, value: string): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindMultiAttribute', slice.call(arguments)); }\n\n    const attributes = parseMultiAttributeBinding(value);\n    let attr: IAttrLike;\n    for (let i = 0, ii = attributes.length; i < ii; ++i) {\n      attr = attributes[i];\n      const attrSyntax = this.attrParser.parse(attr.name, attr.value);\n      const command = this.resources.getBindingCommand(attrSyntax);\n      const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n      const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n      let bindable = attrInfo.bindables[attrSyntax.target];\n      if (bindable === undefined) {\n        // everything in a dynamicOptions expression must be used, so if it's not a bindable then we create one on the spot\n        bindable = attrInfo.bindables[attrSyntax.target] = new BindableInfo(attrSyntax.target, BindingMode.toView);\n      }\n\n      symbol.bindings.push(new BindingSymbol(command, bindable, expr, attrSyntax.rawValue, attrSyntax.target));\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindPlainAttribute(attrSyntax: AttrSyntax): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindPlainAttribute', slice.call(arguments)); }\n\n    if (attrSyntax.rawValue.length === 0) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    const command = this.resources.getBindingCommand(attrSyntax);\n    const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n    const manifest = this.manifest;\n    const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n\n    if (manifest.flags & SymbolFlags.isCustomElement) {\n      const bindable = (manifest as CustomElementSymbol).bindables[attrSyntax.target];\n      if (bindable !== undefined) {\n        // if the attribute name matches a bindable property name, add it regardless of whether it's a command, interpolation, or just a plain string;\n        // the template compiler will translate it to the correct instruction\n        (manifest as CustomElementSymbol).bindings.push(new BindingSymbol(command, bindable, expr, attrSyntax.rawValue, attrSyntax.target));\n        manifest.isTarget = true;\n      } else if (expr !== null || attrSyntax.target === 'ref') {\n        // if it does not map to a bindable, only add it if we were able to parse an expression (either a command or interpolation)\n        manifest.attributes.push(new PlainAttributeSymbol(attrSyntax, command, expr));\n        manifest.isTarget = true;\n      }\n    } else if (expr !== null || attrSyntax.target === 'ref') {\n      // either a binding command, an interpolation, or a ref\n      manifest.attributes.push(new PlainAttributeSymbol(attrSyntax, command, expr));\n      manifest.isTarget = true;\n    } else if (manifest === this.surrogate) {\n      // any attributes, even if they are plain (no command/interpolation etc), should be added if they\n      // are on the surrogate element\n      manifest.attributes.push(new PlainAttributeSymbol(attrSyntax, command, expr));\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private declareReplacePart(node: HTMLTemplateElement | HTMLElement): ReplacePartSymbol {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.declareReplacePart', slice.call(arguments)); }\n\n    const name = node.getAttribute('replace-part');\n    if (name === null) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return null;\n    }\n    node.removeAttribute('replace-part');\n\n    const symbol = new ReplacePartSymbol(name);\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return symbol;\n  }\n}\n\nfunction processInterpolationText(symbol: TextSymbol): void {\n  const node = symbol.physicalNode as Text;\n  const parentNode = node.parentNode;\n  while (node.nextSibling !== null && node.nextSibling.nodeType === NodeType.Text) {\n    parentNode.removeChild(node.nextSibling);\n  }\n  node.textContent = '';\n  parentNode.insertBefore(symbol.marker as Node, node);\n}\n\n/**\n * A (temporary) standalone function that purely does the DOM processing (lifting) related to template controllers.\n * It's a first refactoring step towards separating DOM parsing/binding from mutations.\n */\nfunction processTemplateControllers(dom: IDOM, manifestProxy: IParentNodeSymbol, manifest: IElementSymbol): void {\n  const manifestNode = manifest.physicalNode as HTMLElement;\n  let current = manifestProxy as TemplateControllerSymbol;\n  let currentTemplate: HTMLTemplateElement;\n  while ((current as IParentNodeSymbol) !== manifest) {\n    if (current.template === manifest) {\n      // the DOM linkage is still in its original state here so we can safely assume the parentNode is non-null\n      manifestNode.parentNode.replaceChild(current.marker as Node, manifestNode);\n\n      // if the manifest is a template element (e.g. <template repeat.for=\"...\">) then we can skip one lift operation\n      // and simply use the template directly, saving a bit of work\n      if (manifestNode.nodeName === 'TEMPLATE') {\n        current.physicalNode = manifestNode as HTMLTemplateElement;\n        // the template could safely stay without affecting anything visible, but let's keep the DOM tidy\n        manifestNode.remove();\n      } else {\n        // the manifest is not a template element so we need to wrap it in one\n        currentTemplate = current.physicalNode = dom.createTemplate() as HTMLTemplateElement;\n        currentTemplate.content.appendChild(manifestNode);\n      }\n    } else {\n      currentTemplate = current.physicalNode = dom.createTemplate() as HTMLTemplateElement;\n      currentTemplate.content.appendChild(current.marker as Node);\n    }\n    manifestNode.removeAttribute(current.syntax.rawName);\n    current = current.template as TemplateControllerSymbol;\n  }\n}\n\nfunction processReplacePart(dom: IDOM, replacePart: ReplacePartSymbol, manifestProxy: IParentNodeSymbol | ISymbolWithMarker): void {\n    let proxyNode: HTMLElement;\n    let currentTemplate: HTMLTemplateElement;\n    if (manifestProxy.flags & SymbolFlags.hasMarker) {\n      proxyNode = (manifestProxy as ISymbolWithMarker).marker as HTMLElement;\n    } else {\n      proxyNode = manifestProxy.physicalNode as HTMLElement;\n    }\n    if (proxyNode.nodeName === 'TEMPLATE') {\n      // if it's a template element, no need to do anything special, just assign it to the replacePart\n      replacePart.physicalNode = proxyNode as HTMLTemplateElement;\n    } else {\n      // otherwise wrap the replace-part in a template\n      currentTemplate = replacePart.physicalNode = dom.createTemplate() as HTMLTemplateElement;\n      currentTemplate.content.appendChild(proxyNode);\n    }\n}\n\ninterface IAttrLike {\n  name: string;\n  value: string;\n}\n\nclass ParserState {\n  public input: string;\n  public index: number;\n  public length: number;\n\n  constructor(input: string) {\n    this.input = input;\n    this.index = 0;\n    this.length = input.length;\n  }\n}\n\nconst fromCharCode = String.fromCharCode;\n\n// TODO: move to expression parser\nfunction parseMultiAttributeBinding(input: string): IAttrLike[] {\n  const attributes: IAttrLike[] = [];\n\n  const state = new ParserState(input);\n  const length = state.length;\n  let name: string;\n  let value: string;\n\n  while (state.index < length) {\n    name = scanAttributeName(state);\n    if (name.length === 0) {\n      return attributes;\n    }\n    value = scanAttributeValue(state);\n    attributes.push({ name, value });\n  }\n\n  return attributes;\n}\n\nfunction scanAttributeName(state: ParserState): string {\n  const start = state.index;\n  const { length, input } = state;\n  while (state.index < length && input.charCodeAt(++state.index) !== Char.Colon);\n\n  return input.slice(start, state.index).trim();\n}\n\nconst enum Char {\n  DoubleQuote    = 0x22,\n  SingleQuote    = 0x27,\n  Slash          = 0x2F,\n  Semicolon      = 0x3B,\n  Colon          = 0x3A\n}\n\nfunction scanAttributeValue(state: ParserState): string {\n  ++state.index;\n  const { length, input } = state;\n  let token = '';\n  let inString = false;\n  let quote = null;\n  let ch = 0;\n  while (state.index < length) {\n    ch = input.charCodeAt(state.index);\n    switch (ch) {\n      case Char.Semicolon:\n        ++state.index;\n        return token.trim();\n      case Char.Slash:\n        ch = input.charCodeAt(++state.index);\n        if (ch === Char.DoubleQuote) {\n          if (inString === false) {\n            inString = true;\n            quote = Char.DoubleQuote;\n          } else if (quote === Char.DoubleQuote) {\n            inString = false;\n            quote = null;\n          }\n        }\n        token += `\\\\${fromCharCode(ch)}`;\n        break;\n      case Char.SingleQuote:\n        if (inString === false) {\n          inString = true;\n          quote = Char.SingleQuote;\n        } else if (quote === Char.SingleQuote) {\n          inString = false;\n          quote = null;\n        }\n        token += '\\'';\n        break;\n      default:\n        token += fromCharCode(ch);\n    }\n    ++state.index;\n  }\n\n  return token.trim();\n}\n","import { DI, IContainer, InterfaceSymbol, IResolver, Profiler, Registration } from '@aurelia/kernel';\nimport { IDOM, INode } from '@aurelia/runtime';\n\n/**\n * Utility that creates a `HTMLTemplateElement` out of string markup or an existing DOM node.\n *\n * It is idempotent in the sense that passing in an existing template element will simply return that template element,\n * so it is always safe to pass in a node without causing unnecessary DOM parsing or template creation.\n */\nexport interface ITemplateElementFactory {\n  /**\n   * Create a `HTMLTemplateElement` from a provided html string.\n   *\n   * @param markup A raw html string that may or may not be wrapped in `<template></template>`\n   */\n  createTemplate(markup: string): INode;\n  /**\n   * Create a `HTMLTemplateElement` from a provided DOM node. If the node is already a template, it\n   * will be returned as-is (and removed from the DOM).\n   *\n   * @param node A DOM node that may or may not be wrapped in `<template></template>`\n   */\n  createTemplate(node: INode): INode;\n  /**\n   * Create a `HTMLTemplateElement` from a provided DOM node or html string.\n   *\n   * @param input A DOM node or raw html string that may or may not be wrapped in `<template></template>`\n   */\n  createTemplate(input: unknown): INode;\n  createTemplate(input: unknown): INode;\n}\n\n// For some reason rollup complains about `DI.createInterface<ITemplateElementFactory>().noDefault()` with this message:\n// \"semantic error TS2742 The inferred type of 'ITemplateElementFactory' cannot be named without a reference to '@aurelia/jit/node_modules/@aurelia/kernel'. This is likely not portable. A type annotation is necessary\"\n// So.. investigate why that happens (or rather, why it *only* happens here and not for the other 50)\nexport const ITemplateElementFactory: InterfaceSymbol<ITemplateElementFactory> = DI.createInterface('ITemplateElementFactory').noDefault();\n\nconst { enter, leave } = Profiler.createTimer('TemplateElementFactory');\n\n/**\n * Default implementation for `ITemplateFactory` for use in an HTML based runtime.\n *\n * @internal\n */\nexport class HTMLTemplateElementFactory implements ITemplateElementFactory {\n  public static readonly inject: ReadonlyArray<Function> = [IDOM];\n\n  private readonly dom: IDOM;\n  private template: HTMLTemplateElement;\n\n  constructor(dom: IDOM) {\n    this.dom = dom;\n    this.template = dom.createTemplate() as HTMLTemplateElement;\n  }\n\n  public static register(container: IContainer): IResolver<ITemplateElementFactory> {\n    return Registration.singleton(ITemplateElementFactory, this).register(container);\n  }\n\n  public createTemplate(markup: string): HTMLTemplateElement;\n  public createTemplate(node: Node): HTMLTemplateElement;\n  public createTemplate(input: unknown): HTMLTemplateElement;\n  public createTemplate(input: string | Node): HTMLTemplateElement {\n    if (Profiler.enabled) { enter(); }\n    if (typeof input === 'string') {\n      const template = this.template;\n      template.innerHTML = input;\n      const node = template.content.firstElementChild;\n      // if the input is either not wrapped in a template or there is more than one node,\n      // return the whole template that wraps it/them (and create a new one for the next input)\n      if (node === null || node.nodeName !== 'TEMPLATE' || node.nextElementSibling !== null) {\n        this.template = this.dom.createTemplate() as HTMLTemplateElement;\n        if (Profiler.enabled) { leave(); }\n        return template;\n      }\n      // the node to return is both a template and the only node, so return just the node\n      // and clean up the template for the next input\n      template.content.removeChild(node);\n      if (Profiler.enabled) { leave(); }\n      return node as HTMLTemplateElement;\n    }\n    if (input.nodeName !== 'TEMPLATE') {\n      // if we get one node that is not a template, wrap it in one\n      const template = this.dom.createTemplate() as HTMLTemplateElement;\n      template.content.appendChild(input);\n      if (Profiler.enabled) { leave(); }\n      return template;\n    }\n    // we got a template element, remove it from the DOM if it's present there and don't\n    // do any other processing\n    if (input.parentNode !== null) {\n      input.parentNode.removeChild(input);\n    }\n    if (Profiler.enabled) { leave(); }\n    return input as HTMLTemplateElement;\n  }\n}\n","import {\n  BindingSymbol,\n  CustomAttributeSymbol,\n  CustomElementSymbol,\n  IAttributeParser,\n  IAttributeSymbol,\n  IElementSymbol,\n  INodeSymbol,\n  IParentNodeSymbol,\n  ISymbolWithBindings,\n  LetElementSymbol,\n  PlainAttributeSymbol,\n  PlainElementSymbol,\n  ReplacePartSymbol,\n  ResourceModel,\n  SymbolFlags,\n  TemplateControllerSymbol,\n  TextSymbol\n} from '@aurelia/jit';\nimport { IContainer, IResolver, IResourceDescriptions, PLATFORM, Profiler, Registration } from '@aurelia/kernel';\nimport {\n  HydrateAttributeInstruction,\n  HydrateElementInstruction,\n  HydrateTemplateController,\n  IBuildInstruction,\n  IDOM,\n  IExpressionParser,\n  ILetBindingInstruction,\n  Interpolation,\n  InterpolationInstruction,\n  IsBindingBehavior,\n  ITargetedInstruction,\n  ITemplateCompiler,\n  ITemplateDefinition,\n  LetBindingInstruction,\n  LetElementInstruction,\n  RefBindingInstruction,\n  SetPropertyInstruction,\n  TemplateDefinition\n} from '@aurelia/runtime';\nimport {\n  HTMLAttributeInstruction,\n  HTMLInstructionRow,\n  SetAttributeInstruction,\n  TextBindingInstruction\n} from '@aurelia/runtime-html';\nimport { TemplateBinder } from './template-binder';\nimport { ITemplateElementFactory } from './template-element-factory';\n\nconst buildNotRequired: IBuildInstruction = Object.freeze({\n  required: false,\n  compiler: 'default'\n});\n\nconst { enter, leave } = Profiler.createTimer('TemplateCompiler');\n\n/**\n * Default (runtime-agnostic) implementation for `ITemplateCompiler`.\n *\n * @internal\n */\nexport class TemplateCompiler implements ITemplateCompiler {\n  public static readonly inject: ReadonlyArray<Function> = [ITemplateElementFactory, IAttributeParser, IExpressionParser];\n\n  private readonly factory: ITemplateElementFactory;\n  private readonly attrParser: IAttributeParser;\n  private readonly exprParser: IExpressionParser;\n\n  /**\n   * The instructions array for the currently instruction-collecting `ITemplateDefinition`\n   */\n  private instructionRows: HTMLInstructionRow[];\n\n  public get name(): string {\n    return 'default';\n  }\n\n  constructor(factory: ITemplateElementFactory, attrParser: IAttributeParser, exprParser: IExpressionParser) {\n    this.factory = factory;\n    this.attrParser = attrParser;\n    this.exprParser = exprParser;\n    this.instructionRows = null;\n  }\n\n  public static register(container: IContainer): IResolver<ITemplateCompiler> {\n    return Registration.singleton(ITemplateCompiler, this).register(container);\n  }\n\n  public compile(dom: IDOM, definition: ITemplateDefinition, descriptions: IResourceDescriptions): TemplateDefinition {\n    if (Profiler.enabled) { enter(); }\n    const binder = new TemplateBinder(dom, new ResourceModel(descriptions), this.attrParser, this.exprParser);\n    const template = definition.template = this.factory.createTemplate(definition.template) as HTMLTemplateElement;\n    const surrogate = binder.bind(template);\n    if (definition.instructions === undefined || definition.instructions === PLATFORM.emptyArray) {\n      definition.instructions = [];\n    }\n    if (surrogate.hasSlots === true) {\n      definition.hasSlots = true;\n    }\n\n    this.instructionRows = definition.instructions as HTMLInstructionRow[];\n\n    const attributes = surrogate.attributes;\n    const len = attributes.length;\n    if (len > 0) {\n      let surrogates: ITargetedInstruction[];\n      if (definition.surrogates === undefined || definition.surrogates === PLATFORM.emptyArray) {\n        definition.surrogates = Array(len);\n      }\n      surrogates = definition.surrogates;\n      for (let i = 0; i < len; ++i) {\n        surrogates[i] = this.compileAttribute(attributes[i]);\n      }\n    }\n\n    this.compileChildNodes(surrogate);\n\n    this.instructionRows = null;\n\n    if (Profiler.enabled) { leave(); }\n    return definition as TemplateDefinition;\n  }\n\n  private compileChildNodes(parent: IElementSymbol): void {\n    if (parent.flags & SymbolFlags.hasChildNodes) {\n      const { childNodes } = parent;\n      let childNode: INodeSymbol;\n      const ii = childNodes.length;\n      for (let i = 0; i < ii; ++i) {\n        childNode = childNodes[i];\n        if (childNode.flags & SymbolFlags.isText) {\n          this.instructionRows.push([new TextBindingInstruction((childNode as TextSymbol).interpolation)]);\n        } else if (childNode.flags & SymbolFlags.isLetElement) {\n          const bindings = (childNode as LetElementSymbol).bindings;\n          const instructions: ILetBindingInstruction[] = [];\n          let binding: BindingSymbol;\n          const jj = bindings.length;\n          for (let j = 0; j < jj; ++j) {\n            binding = bindings[j];\n            instructions[j] = new LetBindingInstruction(binding.expression as IsBindingBehavior, binding.target);\n          }\n          this.instructionRows.push([new LetElementInstruction(instructions, (childNode as LetElementSymbol).toViewModel)]);\n        } else {\n          this.compileParentNode(childNode as IParentNodeSymbol);\n        }\n      }\n    }\n  }\n\n  private compileCustomElement(symbol: CustomElementSymbol): void {\n    // offset 1 to leave a spot for the hydrate instruction so we don't need to create 2 arrays with a spread etc\n    const instructionRow = this.compileAttributes(symbol, 1) as HTMLInstructionRow;\n    instructionRow[0] = new HydrateElementInstruction(\n      symbol.res,\n      this.compileBindings(symbol),\n      this.compileParts(symbol)\n    );\n\n    this.instructionRows.push(instructionRow);\n  }\n\n  private compilePlainElement(symbol: PlainElementSymbol): void {\n    const attributes = this.compileAttributes(symbol, 0);\n    if (attributes.length > 0) {\n      this.instructionRows.push(attributes as HTMLInstructionRow);\n    }\n    this.compileChildNodes(symbol);\n  }\n\n  private compileParentNode(symbol: IParentNodeSymbol): void {\n    switch (symbol.flags & SymbolFlags.type) {\n      case SymbolFlags.isCustomElement:\n        this.compileCustomElement(symbol as CustomElementSymbol);\n        break;\n      case SymbolFlags.isPlainElement:\n        this.compilePlainElement(symbol as PlainElementSymbol);\n        break;\n      case SymbolFlags.isTemplateController:\n        this.compileTemplateController(symbol as TemplateControllerSymbol);\n    }\n  }\n\n  private compileTemplateController(symbol: TemplateControllerSymbol): void {\n    const bindings = this.compileBindings(symbol);\n    const instructionRowsSave = this.instructionRows;\n    const controllerInstructions = this.instructionRows = [];\n    this.compileParentNode(symbol.template);\n    this.instructionRows = instructionRowsSave;\n\n    const def = {\n      name: symbol.partName === null ? symbol.res : symbol.partName,\n      template: symbol.physicalNode,\n      instructions: controllerInstructions,\n      build: buildNotRequired\n    };\n    this.instructionRows.push([new HydrateTemplateController(def, symbol.res, bindings, symbol.res === 'else')]);\n  }\n\n  private compileBindings(symbol: ISymbolWithBindings): HTMLAttributeInstruction[] {\n    let bindingInstructions: HTMLAttributeInstruction[];\n    if (symbol.flags & SymbolFlags.hasBindings) {\n      // either a custom element with bindings, a custom attribute / template controller with dynamic options,\n      // or a single value custom attribute binding\n      const { bindings } = symbol;\n      const len = bindings.length;\n      bindingInstructions = Array(len);\n      let i = 0;\n      for (; i < len; ++i) {\n        bindingInstructions[i] = this.compileBinding(bindings[i]);\n      }\n    } else {\n      bindingInstructions = PLATFORM.emptyArray as HTMLAttributeInstruction[];\n    }\n    return bindingInstructions;\n  }\n\n  private compileBinding(symbol: BindingSymbol): HTMLAttributeInstruction {\n    if (symbol.command === null) {\n      // either an interpolation or a normal string value assigned to an element or attribute binding\n      if (symbol.expression === null) {\n        // the template binder already filtered out non-bindables, so we know we need a setProperty here\n        return new SetPropertyInstruction(symbol.rawValue, symbol.bindable.propName);\n      } else {\n        // either an element binding interpolation or a dynamic options attribute binding interpolation\n        return new InterpolationInstruction(symbol.expression as Interpolation, symbol.bindable.propName);\n      }\n    } else {\n      // either an element binding command, dynamic options attribute binding command,\n      // or custom attribute / template controller (single value) binding command\n      return symbol.command.compile(symbol) as HTMLAttributeInstruction;\n    }\n  }\n\n  private compileAttributes(symbol: IElementSymbol, offset: number): HTMLAttributeInstruction[] {\n    let attributeInstructions: HTMLAttributeInstruction[];\n    if (symbol.flags & SymbolFlags.hasAttributes) {\n      // any attributes on a custom element (which are not bindables) or a plain element\n      const { attributes } = symbol;\n      const len = attributes.length;\n      attributeInstructions = Array(offset + len);\n      for (let i = 0; i < len; ++i) {\n        attributeInstructions[i + offset] = this.compileAttribute(attributes[i]);\n      }\n    } else if (offset > 0) {\n      attributeInstructions = Array(offset);\n    } else {\n      attributeInstructions = PLATFORM.emptyArray as HTMLAttributeInstruction[];\n    }\n    return attributeInstructions;\n  }\n\n  private compileCustomAttribute(symbol: CustomAttributeSymbol): HTMLAttributeInstruction {\n    // a normal custom attribute (not template controller)\n    const bindings = this.compileBindings(symbol);\n    return new HydrateAttributeInstruction(symbol.res, bindings);\n  }\n\n  private compilePlainAttribute(symbol: PlainAttributeSymbol): HTMLAttributeInstruction {\n    if (symbol.command === null) {\n      if (symbol.expression === null) {\n        // a plain attribute on a surrogate\n        return new SetAttributeInstruction(symbol.syntax.rawValue, symbol.syntax.target);\n      } else {\n        // a plain attribute with an interpolation\n        return new InterpolationInstruction(symbol.expression as Interpolation, symbol.syntax.target);\n      }\n    } else {\n      // a plain attribute with a binding command\n      return symbol.command.compile(symbol) as HTMLAttributeInstruction;\n    }\n  }\n\n  private compileAttribute(symbol: IAttributeSymbol): HTMLAttributeInstruction {\n    if (symbol.syntax.target === 'ref') {\n      return new RefBindingInstruction(symbol.syntax.rawValue);\n    }\n    // any attribute on a custom element (which is not a bindable) or a plain element\n    if (symbol.flags & SymbolFlags.isCustomAttribute) {\n      return this.compileCustomAttribute(symbol as CustomAttributeSymbol);\n    } else {\n      return this.compilePlainAttribute(symbol as PlainAttributeSymbol);\n    }\n  }\n\n  private compileParts(symbol: CustomElementSymbol): Record<string, ITemplateDefinition> {\n    let parts: Record<string, ITemplateDefinition>;\n    if (symbol.flags & SymbolFlags.hasParts) {\n      parts = {};\n      const replaceParts = symbol.parts;\n      const ii = replaceParts.length;\n      let instructionRowsSave: HTMLInstructionRow[];\n      let partInstructions: HTMLInstructionRow[];\n      let replacePart: ReplacePartSymbol;\n      for (let i = 0; i < ii; ++i) {\n        replacePart = replaceParts[i];\n        instructionRowsSave = this.instructionRows;\n        partInstructions = this.instructionRows = [];\n        this.compileParentNode(replacePart.template);\n        parts[replacePart.name] = {\n          name: replacePart.name,\n          template: replacePart.physicalNode,\n          instructions: partInstructions,\n          build: buildNotRequired\n        };\n        this.instructionRows = instructionRowsSave;\n      }\n    } else {\n      parts = PLATFORM.emptyObject;\n    }\n    return parts;\n  }\n}\n","import {\n  DefaultBindingLanguage as JitDefaultBindingLanguage,\n  DefaultBindingSyntax as JitDefaultBindingSyntax,\n  DefaultComponents as JitDefaultComponents\n} from '@aurelia/jit';\nimport { DI, IContainer, IRegistry } from '@aurelia/kernel';\nimport { BasicConfiguration as RuntimeHtmlBasicConfiguration } from '@aurelia/runtime-html';\nimport {\n  CaptureBindingCommand,\n  DelegateBindingCommand,\n  TriggerBindingCommand\n} from './binding-command';\nimport { TemplateCompiler } from './template-compiler';\nimport { HTMLTemplateElementFactory } from './template-element-factory';\n\nexport const ITemplateCompilerRegistration = TemplateCompiler as IRegistry;\nexport const ITemplateElementFactoryRegistration = HTMLTemplateElementFactory as IRegistry;\n\n/**\n * Default HTML-specific (but environment-agnostic) implementations for the following interfaces:\n * - `ITemplateCompiler`\n * - `ITemplateElementFactory`\n */\nexport const DefaultComponents = [\n  ITemplateCompilerRegistration,\n  ITemplateElementFactoryRegistration\n];\n\nexport const TriggerBindingCommandRegistration = TriggerBindingCommand as IRegistry;\nexport const DelegateBindingCommandRegistration = DelegateBindingCommand as IRegistry;\nexport const CaptureBindingCommandRegistration = CaptureBindingCommand as IRegistry;\n\n/**\n * Default HTML-specific (but environment-agnostic) binding commands:\n * - Event listeners: `.trigger`, `.delegate`, `.capture`\n */\nexport const DefaultBindingLanguage = [\n  TriggerBindingCommandRegistration,\n  DelegateBindingCommandRegistration,\n  CaptureBindingCommandRegistration\n];\n\n/**\n * A DI configuration object containing html-specific (but environment-agnostic) registrations:\n * - `BasicConfiguration` from `@aurelia/runtime-html`\n * - `DefaultComponents` from `@aurelia/jit`\n * - `DefaultBindingSyntax` from `@aurelia/jit`\n * - `DefaultBindingLanguage` from `@aurelia/jit`\n * - `DefaultComponents`\n * - `DefaultBindingLanguage`\n */\nexport const BasicConfiguration = {\n  /**\n   * Apply this configuration to the provided container.\n   */\n  register(container: IContainer): IContainer {\n    return RuntimeHtmlBasicConfiguration\n      .register(container)\n      .register(\n        ...JitDefaultComponents,\n        ...JitDefaultBindingSyntax,\n        ...JitDefaultBindingLanguage,\n        ...DefaultComponents,\n        ...DefaultBindingLanguage\n      );\n  },\n  /**\n   * Create a new container with this configuration applied to it.\n   */\n  createContainer(): IContainer {\n    return this.register(DI.createContainer());\n  }\n};\n","import { ITemplateDefinition, TargetedInstructionType } from '@aurelia/runtime';\nimport { HTMLTargetedInstruction, HTMLTargetedInstructionType, NodeType } from '@aurelia/runtime-html';\n\nexport function stringifyDOM(node: Node, depth: number): string {\n  const indent = ' '.repeat(depth);\n  let output = indent;\n  output += `Node: ${node.nodeName}`;\n  if (node.nodeType === NodeType.Text) {\n    output += ` \"${node.textContent}\"`;\n  }\n  if (node.nodeType === NodeType.Element) {\n    let i = 0;\n    let attr;\n    const attributes = (node as HTMLElement).attributes;\n    const len = attributes.length;\n    for (; i < len; ++i) {\n      attr = attributes[i];\n      output += ` ${attr.name}=${attr.value}`;\n    }\n  }\n  output += '\\n';\n  if (node.nodeType === NodeType.Element) {\n    let i = 0;\n    let childNodes = node.childNodes;\n    let len = childNodes.length;\n    for (; i < len; ++i) {\n      output += stringifyDOM(childNodes[i], depth + 1);\n    }\n    if (node.nodeName === 'TEMPLATE') {\n      i = 0;\n      childNodes = (node as HTMLTemplateElement).content.childNodes;\n      len = childNodes.length;\n      for (; i < len; ++i) {\n        output += stringifyDOM(childNodes[i], depth + 1);\n      }\n    }\n  }\n  return output;\n}\n\nexport function stringifyInstructions(instruction: HTMLTargetedInstruction, depth: number): string {\n  const indent = ' '.repeat(depth);\n  let output = indent;\n  switch (instruction.type) {\n    case HTMLTargetedInstructionType.textBinding:\n      output += 'textBinding\\n';\n      break;\n    case TargetedInstructionType.callBinding:\n      output += 'callBinding\\n';\n      break;\n    case TargetedInstructionType.iteratorBinding:\n      output += 'iteratorBinding\\n';\n      break;\n    case HTMLTargetedInstructionType.listenerBinding:\n      output += 'listenerBinding\\n';\n      break;\n    case TargetedInstructionType.propertyBinding:\n      output += 'propertyBinding\\n';\n      break;\n    case TargetedInstructionType.refBinding:\n      output += 'refBinding\\n';\n      break;\n    case HTMLTargetedInstructionType.stylePropertyBinding:\n      output += 'stylePropertyBinding\\n';\n      break;\n    case TargetedInstructionType.setProperty:\n      output += 'setProperty\\n';\n      break;\n    case HTMLTargetedInstructionType.setAttribute:\n      output += 'setAttribute\\n';\n      break;\n    case TargetedInstructionType.interpolation:\n      output += 'interpolation\\n';\n      break;\n    case TargetedInstructionType.hydrateLetElement:\n      output += 'hydrateLetElement\\n';\n      instruction.instructions.forEach(i => {\n        output += stringifyInstructions(i, depth + 1);\n      });\n      break;\n    case TargetedInstructionType.hydrateAttribute:\n      output += `hydrateAttribute: ${instruction.res}\\n`;\n      instruction.instructions.forEach(i => {\n        output += stringifyInstructions(i as HTMLTargetedInstruction, depth + 1);\n      });\n      break;\n    case TargetedInstructionType.hydrateElement:\n      output += `hydrateElement: ${instruction.res}\\n`;\n      instruction.instructions.forEach(i => {\n        output += stringifyInstructions(i as HTMLTargetedInstruction, depth + 1);\n      });\n      break;\n    case TargetedInstructionType.hydrateTemplateController:\n      output += `hydrateTemplateController: ${instruction.res}\\n`;\n      output += stringifyTemplateDefinition(instruction.def, depth + 1);\n      instruction.instructions.forEach(i => {\n        output += stringifyInstructions(i as HTMLTargetedInstruction, depth + 1);\n      });\n  }\n  return output;\n}\n\nexport function stringifyTemplateDefinition(def: ITemplateDefinition, depth: number): string {\n  const indent = ' '.repeat(depth);\n  let output = indent;\n\n  output += `TemplateDefinition: ${def.name}\\n`;\n  output += stringifyDOM(def.template as Node, depth + 1);\n  output += `${indent} Instructions:\\n`;\n  def.instructions.forEach(row => {\n    output += `${indent}  Row:\\n`;\n    row.forEach(i => {\n      output += stringifyInstructions(i as HTMLTargetedInstruction, depth + 3);\n    });\n  });\n\n  return output;\n}\n"],"names":["TriggerBindingInstruction","getTarget","BindingCommandResource","DelegateBindingInstruction","CaptureBindingInstruction","Profiler","PlainElementSymbol","CustomElementSymbol","LetElementSymbol","PLATFORM","BindableInfo","BindingMode","BindingSymbol","TextSymbol","TemplateControllerSymbol","CustomAttributeSymbol","PlainAttributeSymbol","ReplacePartSymbol","DI","enter","leave","Registration","IDOM","ITemplateCompiler","ResourceModel","TextBindingInstruction","LetBindingInstruction","LetElementInstruction","HydrateElementInstruction","HydrateTemplateController","SetPropertyInstruction","InterpolationInstruction","HydrateAttributeInstruction","SetAttributeInstruction","RefBindingInstruction","IAttributeParser","IExpressionParser","RuntimeHtmlBasicConfiguration","JitDefaultComponents","JitDefaultBindingSyntax","JitDefaultBindingLanguage"],"mappings":"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"}