{"version":3,"file":"index.system.js","sources":["../src/binding-command.ts","../src/template-binder.ts","../src/template-element-factory.ts","../src/template-compiler.ts","../src/configuration.ts","../src/debugging.ts"],"sourcesContent":["import {\n  BindingCommandResource,\n  BindingSymbol,\n  getTarget,\n  IBindingCommand,\n  PlainAttributeSymbol\n} from '@aurelia/jit';\nimport { IRegistry } from '@aurelia/kernel';\nimport { BindingType, IsBindingBehavior } from '@aurelia/runtime';\nimport {\n  CaptureBindingInstruction,\n  DelegateBindingInstruction,\n  HTMLAttributeInstruction,\n  TriggerBindingInstruction\n} from '@aurelia/runtime-html';\n\nexport interface TriggerBindingCommand extends IBindingCommand {}\nexport class TriggerBindingCommand implements IBindingCommand {\n  public static readonly register: IRegistry['register'];\n  public readonly bindingType: BindingType.TriggerCommand;\n\n  constructor() {\n    this.bindingType = BindingType.TriggerCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): HTMLAttributeInstruction {\n    return new TriggerBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\nBindingCommandResource.define('trigger', TriggerBindingCommand);\n\nexport interface DelegateBindingCommand extends IBindingCommand {}\nexport class DelegateBindingCommand implements IBindingCommand {\n  public static readonly register: IRegistry['register'];\n  public readonly bindingType: BindingType.DelegateCommand;\n\n  constructor() {\n    this.bindingType = BindingType.DelegateCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): HTMLAttributeInstruction {\n    return new DelegateBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\nBindingCommandResource.define('delegate', DelegateBindingCommand);\n\nexport interface CaptureBindingCommand extends IBindingCommand {}\nexport class CaptureBindingCommand implements IBindingCommand {\n  public static readonly register: IRegistry['register'];\n  public readonly bindingType: BindingType.CaptureCommand;\n\n  constructor() {\n    this.bindingType = BindingType.CaptureCommand;\n  }\n\n  public compile(binding: PlainAttributeSymbol | BindingSymbol): HTMLAttributeInstruction {\n    return new CaptureBindingInstruction(binding.expression as IsBindingBehavior, getTarget(binding, false));\n  }\n}\nBindingCommandResource.define('capture', CaptureBindingCommand);\n","import {\n  AttrInfo,\n  AttrSyntax,\n  BindableInfo,\n  BindingSymbol,\n  CustomAttributeSymbol,\n  CustomElementSymbol,\n  IAttributeParser,\n  IElementSymbol,\n  IParentNodeSymbol,\n  IResourceAttributeSymbol,\n  ISymbolWithMarker,\n  LetElementSymbol,\n  PlainAttributeSymbol,\n  PlainElementSymbol,\n  ReplacePartSymbol,\n  ResourceModel,\n  SymbolFlags,\n  TemplateControllerSymbol,\n  TextSymbol\n} from '@aurelia/jit';\nimport { PLATFORM, Tracer } from '@aurelia/kernel';\nimport {\n  BindingMode,\n  BindingType,\n  IDOM,\n  IExpressionParser\n} from '@aurelia/runtime';\nimport { NodeType } from '@aurelia/runtime-html';\n\nconst slice = Array.prototype.slice;\n\nconst invalidSurrogateAttribute = {\n  'id': true,\n  'part': true,\n  'replace-part': true\n};\n\nconst attributesToIgnore = {\n  'as-element': true,\n  'part': true,\n  'replace-part': true\n};\n\nexport class TemplateBinder {\n  public dom: IDOM;\n  public resources: ResourceModel;\n  public attrParser: IAttributeParser;\n  public exprParser: IExpressionParser;\n\n  private surrogate: PlainElementSymbol | null;\n\n  // This is any \"original\" (as in, not a template created for a template controller) element.\n  // It collects all attribute symbols except for template controllers and replace-parts.\n  private manifest: IElementSymbol | null;\n\n  // This is the nearest wrapping custom element.\n  // It only collects replace-parts (and inherently everything that the manifest collects, if they are the same instance)\n  private manifestRoot: CustomElementSymbol | null;\n\n  // This is the nearest wrapping custom element relative to the current manifestRoot (the manifestRoot \"one level up\").\n  // It exclusively collects replace-parts that are placed on the current manifestRoot.\n  private parentManifestRoot: CustomElementSymbol | null;\n\n  private partName: string | null;\n\n  constructor(dom: IDOM, resources: ResourceModel, attrParser: IAttributeParser, exprParser: IExpressionParser) {\n    this.dom = dom;\n    this.resources = resources;\n    this.attrParser = attrParser;\n    this.exprParser = exprParser;\n    this.surrogate = null;\n    this.manifest = null;\n    this.manifestRoot = null;\n    this.parentManifestRoot = null;\n    this.partName = null;\n  }\n\n  public bind(node: HTMLTemplateElement): PlainElementSymbol {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bind', slice.call(arguments)); }\n\n    const surrogateSave = this.surrogate;\n    const parentManifestRootSave = this.parentManifestRoot;\n    const manifestRootSave = this.manifestRoot;\n    const manifestSave = this.manifest;\n\n    const manifest = this.surrogate = this.manifest = new PlainElementSymbol(node);\n\n    const attributes = node.attributes;\n    let i = 0;\n    while (i < attributes.length) {\n      const attr = attributes[i];\n      const attrSyntax = this.attrParser.parse(attr.name, attr.value);\n\n      if (invalidSurrogateAttribute[attrSyntax.target] === true) {\n        throw new Error(`Invalid surrogate attribute: ${attrSyntax.target}`);\n        // TODO: use reporter\n      }\n      const attrInfo = this.resources.getAttributeInfo(attrSyntax);\n      if (attrInfo === null) {\n        this.bindPlainAttribute(attrSyntax);\n      } else if (attrInfo.isTemplateController) {\n        throw new Error('Cannot have template controller on surrogate element.');\n        // TODO: use reporter\n      } else {\n        this.bindCustomAttribute(attrSyntax, attrInfo);\n      }\n      ++i;\n    }\n\n    this.bindChildNodes(node);\n\n    this.surrogate = surrogateSave;\n    this.parentManifestRoot = parentManifestRootSave;\n    this.manifestRoot = manifestRootSave;\n    this.manifest = manifestSave;\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return manifest;\n  }\n\n  private bindManifest(parentManifest: IElementSymbol, node: HTMLTemplateElement | HTMLElement): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindManifest', slice.call(arguments)); }\n\n    switch (node.nodeName) {\n      case 'LET':\n        // let cannot have children and has some different processing rules, so return early\n        this.bindLetElement(parentManifest, node);\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n      case 'SLOT':\n        // slot requires no compilation\n        this.surrogate.hasSlots = true;\n        if (Tracer.enabled) { Tracer.leave(); }\n        return;\n    }\n\n    // nodes are processed bottom-up so we need to store the manifests before traversing down and\n    // restore them again afterwards\n    const parentManifestRootSave = this.parentManifestRoot;\n    const manifestRootSave = this.manifestRoot;\n    const manifestSave = this.manifest;\n\n    // get the part name to override the name of the compiled definition\n    this.partName = node.getAttribute('part');\n\n    let manifestRoot: CustomElementSymbol;\n    let name = node.getAttribute('as-element');\n    if (name === null) {\n      name = node.nodeName.toLowerCase();\n    }\n    const elementInfo = this.resources.getElementInfo(name);\n    if (elementInfo === null) {\n      // there is no registered custom element with this name\n      this.manifest = new PlainElementSymbol(node);\n    } else {\n      // it's a custom element so we set the manifestRoot as well (for storing replace-parts)\n      this.parentManifestRoot = this.manifestRoot;\n      manifestRoot = this.manifestRoot = this.manifest = new CustomElementSymbol(this.dom, node, elementInfo);\n    }\n\n    // lifting operations done by template controllers and replace-parts effectively unlink the nodes, so start at the bottom\n    this.bindChildNodes(node);\n\n    // the parentManifest will receive either the direct child nodes, or the template controllers / replace-parts\n    // wrapping them\n    this.bindAttributes(node, parentManifest);\n\n    if (manifestRoot !== undefined && manifestRoot.isContainerless) {\n      node.parentNode.replaceChild(manifestRoot.marker as Node, node);\n    } else if (this.manifest.isTarget) {\n      node.classList.add('au');\n    }\n\n    // restore the stored manifests so the attributes are processed on the correct lavel\n    this.parentManifestRoot = parentManifestRootSave;\n    this.manifestRoot = manifestRootSave;\n    this.manifest = manifestSave;\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindLetElement(parentManifest: IElementSymbol, node: HTMLElement): void {\n    const symbol = new LetElementSymbol(this.dom, node);\n    parentManifest.childNodes.push(symbol);\n\n    const attributes = node.attributes;\n    let i = 0;\n    while (i < attributes.length) {\n      const attr = attributes[i];\n      if (attr.name === 'to-view-model') {\n        node.removeAttribute('to-view-model');\n        symbol.toViewModel = true;\n        continue;\n      }\n      const attrSyntax = this.attrParser.parse(attr.name, attr.value);\n      const command = this.resources.getBindingCommand(attrSyntax);\n      const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n      const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n      const to = PLATFORM.camelCase(attrSyntax.target);\n      const info = new BindableInfo(to, BindingMode.toView);\n      symbol.bindings.push(new BindingSymbol(command, info, expr, attrSyntax.rawValue, to));\n\n      ++i;\n    }\n    node.parentNode.replaceChild(symbol.marker as Node, node);\n  }\n\n  private bindAttributes(node: HTMLTemplateElement | HTMLElement, parentManifest: IElementSymbol): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindAttributes', slice.call(arguments)); }\n\n    const { parentManifestRoot, manifestRoot, manifest } = this;\n    // This is the top-level symbol for the current depth.\n    // If there are no template controllers or replace-parts, it is always the manifest itself.\n    // If there are template controllers, then this will be the outer-most TemplateControllerSymbol.\n    let manifestProxy = manifest as IParentNodeSymbol;\n\n    const replacePart = this.declareReplacePart(node);\n\n    let previousController: TemplateControllerSymbol;\n    let currentController: TemplateControllerSymbol;\n\n    const attributes = node.attributes;\n    let i = 0;\n    while (i < attributes.length) {\n      const attr = attributes[i];\n      ++i;\n      if (attributesToIgnore[attr.name] === true) {\n        continue;\n      }\n      const attrSyntax = this.attrParser.parse(attr.name, attr.value);\n      const attrInfo = this.resources.getAttributeInfo(attrSyntax);\n\n      if (attrInfo === null) {\n        // it's not a custom attribute but might be a regular bound attribute or interpolation (it might also be nothing)\n        this.bindPlainAttribute(attrSyntax);\n      } else if (attrInfo.isTemplateController) {\n        // the manifest is wrapped by the inner-most template controller (if there are multiple on the same element)\n        // so keep setting manifest.templateController to the latest template controller we find\n        currentController = manifest.templateController = this.declareTemplateController(attrSyntax, attrInfo);\n\n        // the proxy and the manifest are only identical when we're at the first template controller (since the controller\n        // is assigned to the proxy), so this evaluates to true at most once per node\n        if (manifestProxy === manifest) {\n          currentController.template = manifest;\n          manifestProxy = currentController;\n        } else {\n          currentController.templateController = previousController;\n          currentController.template = previousController.template;\n          previousController.template = currentController;\n        }\n        previousController = currentController;\n      } else {\n        // a regular custom attribute\n        this.bindCustomAttribute(attrSyntax, attrInfo);\n      }\n    }\n\n    processTemplateControllers(this.dom, manifestProxy, manifest);\n\n    if (replacePart === null) {\n      // the proxy is either the manifest itself or the outer-most controller; add it directly to the parent\n      parentManifest.childNodes.push(manifestProxy);\n    } else {\n      // there is a replace-part attribute on this node, so add it to the parts collection of the manifestRoot\n      // instead of to the childNodes\n      replacePart.parent = parentManifest;\n      replacePart.template = manifestProxy;\n\n      // if the current manifest is also the manifestRoot, it means the replace-part sits on a custom\n      // element, so add the part to the parent wrapping custom element instead\n      const partOwner = manifest === manifestRoot ? parentManifestRoot : manifestRoot;\n      partOwner.parts.push(replacePart);\n\n      processReplacePart(this.dom, replacePart, manifestProxy);\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindChildNodes(node: HTMLTemplateElement | HTMLElement): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindChildNodes', slice.call(arguments)); }\n\n    let childNode: ChildNode;\n    if (node.nodeName === 'TEMPLATE') {\n      childNode = (node as HTMLTemplateElement).content.firstChild;\n    } else {\n      childNode = node.firstChild;\n    }\n\n    let nextChild: ChildNode;\n    while (childNode !== null) {\n      switch (childNode.nodeType) {\n        case NodeType.Element:\n          nextChild = childNode.nextSibling as ChildNode;\n          this.bindManifest(this.manifest, childNode as HTMLElement);\n          childNode = nextChild;\n          break;\n        case NodeType.Text:\n          childNode = this.bindText(childNode as Text).nextSibling as ChildNode;\n          break;\n        case NodeType.CDATASection:\n        case NodeType.ProcessingInstruction:\n        case NodeType.Comment:\n        case NodeType.DocumentType:\n          childNode = childNode.nextSibling as ChildNode;\n          break;\n        case NodeType.Document:\n        case NodeType.DocumentFragment:\n          childNode = childNode.firstChild;\n      }\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindText(node: Text): ChildNode {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindText', slice.call(arguments)); }\n    const interpolation = this.exprParser.parse(node.wholeText, BindingType.Interpolation);\n    if (interpolation !== null) {\n      const symbol = new TextSymbol(this.dom, node, interpolation);\n      this.manifest.childNodes.push(symbol);\n      processInterpolationText(symbol);\n    }\n    while (node.nextSibling !== null && node.nextSibling.nodeType === NodeType.Text) {\n      node = node.nextSibling as Text;\n    }\n    if (Tracer.enabled) { Tracer.leave(); }\n    return node;\n  }\n\n  private declareTemplateController(attrSyntax: AttrSyntax, attrInfo: AttrInfo): TemplateControllerSymbol {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.declareTemplateController', slice.call(arguments)); }\n\n    let symbol: TemplateControllerSymbol;\n    // dynamicOptions logic here is similar to (and explained in) bindCustomAttribute\n    const command = this.resources.getBindingCommand(attrSyntax);\n    if (command === null && attrInfo.hasDynamicOptions) {\n      symbol = new TemplateControllerSymbol(this.dom, attrSyntax, attrInfo, this.partName);\n      this.partName = null;\n      this.bindMultiAttribute(symbol, attrInfo, attrSyntax.rawValue);\n    } else {\n      symbol = new TemplateControllerSymbol(this.dom, attrSyntax, attrInfo, this.partName);\n      const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n      const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n      symbol.bindings.push(new BindingSymbol(command, attrInfo.bindable, expr, attrSyntax.rawValue, attrSyntax.target));\n      this.partName = null;\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return symbol;\n  }\n\n  private bindCustomAttribute(attrSyntax: AttrSyntax, attrInfo: AttrInfo): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindCustomAttribute', slice.call(arguments)); }\n\n    const command = this.resources.getBindingCommand(attrSyntax);\n    let symbol: CustomAttributeSymbol;\n    if (command === null && attrInfo.hasDynamicOptions) {\n      // a dynamicOptions (semicolon separated binding) is only valid without a binding command;\n      // the binding commands must be declared in the dynamicOptions expression itself\n      symbol = new CustomAttributeSymbol(attrSyntax, attrInfo);\n      this.bindMultiAttribute(symbol, attrInfo, attrSyntax.rawValue);\n    } else {\n      // we've either got a command (with or without dynamicOptions, the latter maps to the first bindable),\n      // or a null command but without dynamicOptions (which may be an interpolation or a normal string)\n      symbol = new CustomAttributeSymbol(attrSyntax, attrInfo);\n      const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n      const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n      symbol.bindings.push(new BindingSymbol(command, attrInfo.bindable, expr, attrSyntax.rawValue, attrSyntax.target));\n    }\n    this.manifest.attributes.push(symbol);\n    this.manifest.isTarget = true;\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindMultiAttribute(symbol: IResourceAttributeSymbol, attrInfo: AttrInfo, value: string): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindMultiAttribute', slice.call(arguments)); }\n\n    const attributes = parseMultiAttributeBinding(value);\n    let attr: IAttrLike;\n    for (let i = 0, ii = attributes.length; i < ii; ++i) {\n      attr = attributes[i];\n      const attrSyntax = this.attrParser.parse(attr.name, attr.value);\n      const command = this.resources.getBindingCommand(attrSyntax);\n      const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n      const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n      let bindable = attrInfo.bindables[attrSyntax.target];\n      if (bindable === undefined) {\n        // everything in a dynamicOptions expression must be used, so if it's not a bindable then we create one on the spot\n        bindable = attrInfo.bindables[attrSyntax.target] = new BindableInfo(attrSyntax.target, BindingMode.toView);\n      }\n\n      symbol.bindings.push(new BindingSymbol(command, bindable, expr, attrSyntax.rawValue, attrSyntax.target));\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private bindPlainAttribute(attrSyntax: AttrSyntax): void {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.bindPlainAttribute', slice.call(arguments)); }\n\n    if (attrSyntax.rawValue.length === 0) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return;\n    }\n\n    const command = this.resources.getBindingCommand(attrSyntax);\n    const bindingType = command === null ? BindingType.Interpolation : command.bindingType;\n    const manifest = this.manifest;\n    const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);\n\n    if (manifest.flags & SymbolFlags.isCustomElement) {\n      const bindable = (manifest as CustomElementSymbol).bindables[attrSyntax.target];\n      if (bindable !== undefined) {\n        // if the attribute name matches a bindable property name, add it regardless of whether it's a command, interpolation, or just a plain string;\n        // the template compiler will translate it to the correct instruction\n        (manifest as CustomElementSymbol).bindings.push(new BindingSymbol(command, bindable, expr, attrSyntax.rawValue, attrSyntax.target));\n        manifest.isTarget = true;\n      } else if (expr !== null) {\n        // if it does not map to a bindable, only add it if we were able to parse an expression (either a command or interpolation)\n        manifest.attributes.push(new PlainAttributeSymbol(attrSyntax, command, expr));\n        manifest.isTarget = true;\n      }\n    } else if (expr !== null || attrSyntax.target === 'ref') {\n      // either a binding command, an interpolation, or a ref\n      manifest.attributes.push(new PlainAttributeSymbol(attrSyntax, command, expr));\n      manifest.isTarget = true;\n    } else if (manifest === this.surrogate) {\n      // any attributes, even if they are plain (no command/interpolation etc), should be added if they\n      // are on the surrogate element\n      manifest.attributes.push(new PlainAttributeSymbol(attrSyntax, command, expr));\n    }\n\n    if (Tracer.enabled) { Tracer.leave(); }\n  }\n\n  private declareReplacePart(node: HTMLTemplateElement | HTMLElement): ReplacePartSymbol {\n    if (Tracer.enabled) { Tracer.enter('TemplateBinder.declareReplacePart', slice.call(arguments)); }\n\n    const name = node.getAttribute('replace-part');\n    if (name === null) {\n      if (Tracer.enabled) { Tracer.leave(); }\n      return null;\n    }\n    node.removeAttribute('replace-part');\n\n    const symbol = new ReplacePartSymbol(name);\n\n    if (Tracer.enabled) { Tracer.leave(); }\n    return symbol;\n  }\n}\n\nfunction processInterpolationText(symbol: TextSymbol): void {\n  const node = symbol.physicalNode as Text;\n  const parentNode = node.parentNode;\n  while (node.nextSibling !== null && node.nextSibling.nodeType === NodeType.Text) {\n    parentNode.removeChild(node.nextSibling);\n  }\n  node.textContent = '';\n  parentNode.insertBefore(symbol.marker as Node, node);\n}\n\n/**\n * A (temporary) standalone function that purely does the DOM processing (lifting) related to template controllers.\n * It's a first refactoring step towards separating DOM parsing/binding from mutations.\n */\nfunction processTemplateControllers(dom: IDOM, manifestProxy: IParentNodeSymbol, manifest: IElementSymbol): void {\n  const manifestNode = manifest.physicalNode as HTMLElement;\n  let current = manifestProxy as TemplateControllerSymbol;\n  let currentTemplate: HTMLTemplateElement;\n  while ((current as IParentNodeSymbol) !== manifest) {\n    if (current.template === manifest) {\n      // the DOM linkage is still in its original state here so we can safely assume the parentNode is non-null\n      manifestNode.parentNode.replaceChild(current.marker as Node, manifestNode);\n\n      // if the manifest is a template element (e.g. <template repeat.for=\"...\">) then we can skip one lift operation\n      // and simply use the template directly, saving a bit of work\n      if (manifestNode.nodeName === 'TEMPLATE') {\n        current.physicalNode = manifestNode as HTMLTemplateElement;\n        // the template could safely stay without affecting anything visible, but let's keep the DOM tidy\n        manifestNode.remove();\n      } else {\n        // the manifest is not a template element so we need to wrap it in one\n        currentTemplate = current.physicalNode = dom.createTemplate() as HTMLTemplateElement;\n        currentTemplate.content.appendChild(manifestNode);\n      }\n    } else {\n      currentTemplate = current.physicalNode = dom.createTemplate() as HTMLTemplateElement;\n      currentTemplate.content.appendChild(current.marker as Node);\n    }\n    manifestNode.removeAttribute(current.syntax.rawName);\n    current = current.template as TemplateControllerSymbol;\n  }\n}\n\nfunction processReplacePart(dom: IDOM, replacePart: ReplacePartSymbol, manifestProxy: IParentNodeSymbol | ISymbolWithMarker): void {\n    let proxyNode: HTMLElement;\n    let currentTemplate: HTMLTemplateElement;\n    if (manifestProxy.flags & SymbolFlags.hasMarker) {\n      proxyNode = (manifestProxy as ISymbolWithMarker).marker as HTMLElement;\n    } else {\n      proxyNode = manifestProxy.physicalNode as HTMLElement;\n    }\n    if (proxyNode.nodeName === 'TEMPLATE') {\n      // if it's a template element, no need to do anything special, just assign it to the replacePart\n      replacePart.physicalNode = proxyNode as HTMLTemplateElement;\n    } else {\n      // otherwise wrap the replace-part in a template\n      currentTemplate = replacePart.physicalNode = dom.createTemplate() as HTMLTemplateElement;\n      currentTemplate.content.appendChild(proxyNode);\n    }\n}\n\ninterface IAttrLike {\n  name: string;\n  value: string;\n}\n\nclass ParserState {\n  public input: string;\n  public index: number;\n  public length: number;\n\n  constructor(input: string) {\n    this.input = input;\n    this.index = 0;\n    this.length = input.length;\n  }\n}\n\nconst fromCharCode = String.fromCharCode;\n\n// TODO: move to expression parser\nfunction parseMultiAttributeBinding(input: string): IAttrLike[] {\n  const attributes: IAttrLike[] = [];\n\n  const state = new ParserState(input);\n  const length = state.length;\n  let name: string;\n  let value: string;\n\n  while (state.index < length) {\n    name = scanAttributeName(state);\n    if (name.length === 0) {\n      return attributes;\n    }\n    value = scanAttributeValue(state);\n    attributes.push({ name, value });\n  }\n\n  return attributes;\n}\n\nfunction scanAttributeName(state: ParserState): string {\n  const start = state.index;\n  const { length, input } = state;\n  while (state.index < length && input.charCodeAt(++state.index) !== Char.Colon);\n\n  return input.slice(start, state.index).trim();\n}\n\nconst enum Char {\n  DoubleQuote    = 0x22,\n  SingleQuote    = 0x27,\n  Slash          = 0x2F,\n  Semicolon      = 0x3B,\n  Colon          = 0x3A\n}\n\nfunction scanAttributeValue(state: ParserState): string {\n  ++state.index;\n  const { length, input } = state;\n  let token = '';\n  let inString = false;\n  let quote = null;\n  let ch = 0;\n  while (state.index < length) {\n    ch = input.charCodeAt(state.index);\n    switch (ch) {\n      case Char.Semicolon:\n        ++state.index;\n        return token.trim();\n      case Char.Slash:\n        ch = input.charCodeAt(++state.index);\n        if (ch === Char.DoubleQuote) {\n          if (inString === false) {\n            inString = true;\n            quote = Char.DoubleQuote;\n          } else if (quote === Char.DoubleQuote) {\n            inString = false;\n            quote = null;\n          }\n        }\n        token += `\\\\${fromCharCode(ch)}`;\n        break;\n      case Char.SingleQuote:\n        if (inString === false) {\n          inString = true;\n          quote = Char.SingleQuote;\n        } else if (quote === Char.SingleQuote) {\n          inString = false;\n          quote = null;\n        }\n        token += '\\'';\n        break;\n      default:\n        token += fromCharCode(ch);\n    }\n    ++state.index;\n  }\n\n  return token.trim();\n}\n","import { DI, InterfaceSymbol } from '@aurelia/kernel';\nimport { IDOM, INode } from '@aurelia/runtime';\n\n/**\n * Utility that creates a `HTMLTemplateElement` out of string markup or an existing DOM node.\n *\n * It is idempotent in the sense that passing in an existing template element will simply return that template element,\n * so it is always safe to pass in a node without causing unnecessary DOM parsing or template creation.\n */\nexport interface ITemplateElementFactory {\n  /**\n   * Create a `HTMLTemplateElement` from a provided html string.\n   *\n   * @param markup A raw html string that may or may not be wrapped in `<template></template>`\n   */\n  createTemplate(markup: string): INode;\n  /**\n   * Create a `HTMLTemplateElement` from a provided DOM node. If the node is already a template, it\n   * will be returned as-is (and removed from the DOM).\n   *\n   * @param node A DOM node that may or may not be wrapped in `<template></template>`\n   */\n  createTemplate(node: INode): INode;\n  /**\n   * Create a `HTMLTemplateElement` from a provided DOM node or html string.\n   *\n   * @param input A DOM node or raw html string that may or may not be wrapped in `<template></template>`\n   */\n  createTemplate(input: unknown): INode;\n  createTemplate(input: unknown): INode;\n}\n\n// For some reason rollup complains about `DI.createInterface<ITemplateElementFactory>().noDefault()` with this message:\n// \"semantic error TS2742 The inferred type of 'ITemplateElementFactory' cannot be named without a reference to '@aurelia/jit/node_modules/@aurelia/kernel'. This is likely not portable. A type annotation is necessary\"\n// So.. investigate why that happens (or rather, why it *only* happens here and not for the other 50)\nexport const ITemplateElementFactory: InterfaceSymbol<ITemplateElementFactory> = DI.createInterface('ITemplateElementFactory').noDefault();\n\n/**\n * Default implementation for `ITemplateFactory` for use in an HTML based runtime.\n *\n * @internal\n */\nexport class HTMLTemplateElementFactory implements ITemplateElementFactory {\n  public static readonly inject: ReadonlyArray<Function> = [IDOM];\n\n  private dom: IDOM;\n  private template: HTMLTemplateElement;\n\n  constructor(dom: IDOM) {\n    this.dom = dom;\n    this.template = dom.createTemplate() as HTMLTemplateElement;\n  }\n\n  public createTemplate(markup: string): HTMLTemplateElement;\n  public createTemplate(node: Node): HTMLTemplateElement;\n  public createTemplate(input: unknown): HTMLTemplateElement;\n  public createTemplate(input: string | Node): HTMLTemplateElement {\n    if (typeof input === 'string') {\n      const template = this.template;\n      template.innerHTML = input;\n      const node = template.content.firstElementChild;\n      // if the input is either not wrapped in a template or there is more than one node,\n      // return the whole template that wraps it/them (and create a new one for the next input)\n      if (node === null || node.nodeName !== 'TEMPLATE' || node.nextElementSibling !== null) {\n        this.template = this.dom.createTemplate() as HTMLTemplateElement;\n        return template;\n      }\n      // the node to return is both a template and the only node, so return just the node\n      // and clean up the template for the next input\n      template.content.removeChild(node);\n      return node as HTMLTemplateElement;\n    }\n    if (input.nodeName !== 'TEMPLATE') {\n      // if we get one node that is not a template, wrap it in one\n      const template = this.dom.createTemplate() as HTMLTemplateElement;\n      template.content.appendChild(input);\n      return template;\n    }\n    // we got a template element, remove it from the DOM if it's present there and don't\n    // do any other processing\n    if (input.parentNode !== null) {\n      input.parentNode.removeChild(input);\n    }\n    return input as HTMLTemplateElement;\n  }\n}\n","import {\n  BindingSymbol,\n  CustomAttributeSymbol,\n  CustomElementSymbol,\n  IAttributeParser,\n  IAttributeSymbol,\n  IElementSymbol,\n  INodeSymbol,\n  IParentNodeSymbol,\n  ISymbolWithBindings,\n  LetElementSymbol,\n  PlainAttributeSymbol,\n  PlainElementSymbol,\n  ReplacePartSymbol,\n  ResourceModel,\n  SymbolFlags,\n  TemplateControllerSymbol,\n  TextSymbol\n} from '@aurelia/jit';\nimport { IResourceDescriptions, PLATFORM } from '@aurelia/kernel';\nimport {\n  HydrateAttributeInstruction,\n  HydrateElementInstruction,\n  HydrateTemplateController,\n  IBuildInstruction,\n  IDOM,\n  IExpressionParser,\n  ILetBindingInstruction,\n  Interpolation,\n  InterpolationInstruction,\n  IsBindingBehavior,\n  ITargetedInstruction,\n  ITemplateCompiler,\n  ITemplateDefinition,\n  LetBindingInstruction,\n  LetElementInstruction,\n  RefBindingInstruction,\n  SetPropertyInstruction,\n  TemplateDefinition\n} from '@aurelia/runtime';\nimport {\n  HTMLAttributeInstruction,\n  HTMLInstructionRow,\n  SetAttributeInstruction,\n  TextBindingInstruction\n} from '@aurelia/runtime-html';\nimport { TemplateBinder } from './template-binder';\nimport { ITemplateElementFactory } from './template-element-factory';\n\nconst buildNotRequired: IBuildInstruction = Object.freeze({\n  required: false,\n  compiler: 'default'\n});\n\n/**\n * Default (runtime-agnostic) implementation for `ITemplateCompiler`.\n *\n * @internal\n */\nexport class TemplateCompiler implements ITemplateCompiler {\n  public static readonly inject: ReadonlyArray<Function> = [ITemplateElementFactory, IAttributeParser, IExpressionParser];\n\n  private factory: ITemplateElementFactory;\n  private attrParser: IAttributeParser;\n  private exprParser: IExpressionParser;\n\n  /**\n   * The instructions array for the currently instruction-collecting `ITemplateDefinition`\n   */\n  private instructionRows: HTMLInstructionRow[];\n\n  public get name(): string {\n    return 'default';\n  }\n\n  constructor(factory: ITemplateElementFactory, attrParser: IAttributeParser, exprParser: IExpressionParser) {\n    this.factory = factory;\n    this.attrParser = attrParser;\n    this.exprParser = exprParser;\n    this.instructionRows = null;\n  }\n\n  public compile(dom: IDOM, definition: ITemplateDefinition, descriptions: IResourceDescriptions): TemplateDefinition {\n    const binder = new TemplateBinder(dom, new ResourceModel(descriptions), this.attrParser, this.exprParser);\n    const template = definition.template = this.factory.createTemplate(definition.template) as HTMLTemplateElement;\n    const surrogate = binder.bind(template);\n    if (definition.instructions === undefined || definition.instructions === PLATFORM.emptyArray) {\n      definition.instructions = [];\n    }\n    if (surrogate.hasSlots === true) {\n      definition.hasSlots = true;\n    }\n\n    this.instructionRows = definition.instructions as HTMLInstructionRow[];\n\n    const attributes = surrogate.attributes;\n    const len = attributes.length;\n    if (len > 0) {\n      let surrogates: ITargetedInstruction[];\n      if (definition.surrogates === undefined || definition.surrogates === PLATFORM.emptyArray) {\n        definition.surrogates = Array(len);\n      }\n      surrogates = definition.surrogates;\n      for (let i = 0; i < len; ++i) {\n        surrogates[i] = this.compileAttribute(attributes[i]);\n      }\n    }\n\n    this.compileChildNodes(surrogate);\n\n    this.instructionRows = null;\n\n    return definition as TemplateDefinition;\n  }\n\n  private compileChildNodes(parent: IElementSymbol): void {\n    if (parent.flags & SymbolFlags.hasChildNodes) {\n      const { childNodes } = parent;\n      let childNode: INodeSymbol;\n      const ii = childNodes.length;\n      for (let i = 0; i < ii; ++i) {\n        childNode = childNodes[i];\n        if (childNode.flags & SymbolFlags.isText) {\n          this.instructionRows.push([new TextBindingInstruction((childNode as TextSymbol).interpolation)]);\n        } else if (childNode.flags & SymbolFlags.isLetElement) {\n          const bindings = (childNode as LetElementSymbol).bindings;\n          const instructions: ILetBindingInstruction[] = [];\n          let binding: BindingSymbol;\n          const jj = bindings.length;\n          for (let j = 0; j < jj; ++j) {\n            binding = bindings[j];\n            instructions[j] = new LetBindingInstruction(binding.expression as IsBindingBehavior, binding.target);\n          }\n          this.instructionRows.push([new LetElementInstruction(instructions, (childNode as LetElementSymbol).toViewModel)]);\n        } else {\n          this.compileParentNode(childNode as IParentNodeSymbol);\n        }\n      }\n    }\n  }\n\n  private compileCustomElement(symbol: CustomElementSymbol): void {\n    // offset 1 to leave a spot for the hydrate instruction so we don't need to create 2 arrays with a spread etc\n    const instructionRow = this.compileAttributes(symbol, 1) as HTMLInstructionRow;\n    instructionRow[0] = new HydrateElementInstruction(\n      symbol.res,\n      this.compileBindings(symbol),\n      this.compileParts(symbol)\n    );\n\n    this.instructionRows.push(instructionRow);\n  }\n\n  private compilePlainElement(symbol: PlainElementSymbol): void {\n    const attributes = this.compileAttributes(symbol, 0);\n    if (attributes.length > 0) {\n      this.instructionRows.push(attributes as HTMLInstructionRow);\n    }\n    this.compileChildNodes(symbol);\n  }\n\n  private compileParentNode(symbol: IParentNodeSymbol): void {\n    switch (symbol.flags & SymbolFlags.type) {\n      case SymbolFlags.isCustomElement:\n        this.compileCustomElement(symbol as CustomElementSymbol);\n        break;\n      case SymbolFlags.isPlainElement:\n        this.compilePlainElement(symbol as PlainElementSymbol);\n        break;\n      case SymbolFlags.isTemplateController:\n        this.compileTemplateController(symbol as TemplateControllerSymbol);\n    }\n  }\n\n  private compileTemplateController(symbol: TemplateControllerSymbol): void {\n    const bindings = this.compileBindings(symbol);\n    const instructionRowsSave = this.instructionRows;\n    const controllerInstructions = this.instructionRows = [];\n    this.compileParentNode(symbol.template);\n    this.instructionRows = instructionRowsSave;\n\n    const def = {\n      name: symbol.partName === null ? symbol.res : symbol.partName,\n      template: symbol.physicalNode,\n      instructions: controllerInstructions,\n      build: buildNotRequired\n    };\n    this.instructionRows.push([new HydrateTemplateController(def, symbol.res, bindings, symbol.res === 'else')]);\n  }\n\n  private compileBindings(symbol: ISymbolWithBindings): HTMLAttributeInstruction[] {\n    let bindingInstructions: HTMLAttributeInstruction[];\n    if (symbol.flags & SymbolFlags.hasBindings) {\n      // either a custom element with bindings, a custom attribute / template controller with dynamic options,\n      // or a single value custom attribute binding\n      const { bindings } = symbol;\n      const len = bindings.length;\n      bindingInstructions = Array(len);\n      let i = 0;\n      for (; i < len; ++i) {\n        bindingInstructions[i] = this.compileBinding(bindings[i]);\n      }\n    } else {\n      bindingInstructions = PLATFORM.emptyArray as HTMLAttributeInstruction[];\n    }\n    return bindingInstructions;\n  }\n\n  private compileBinding(symbol: BindingSymbol): HTMLAttributeInstruction {\n    if (symbol.command === null) {\n      // either an interpolation or a normal string value assigned to an element or attribute binding\n      if (symbol.expression === null) {\n        // the template binder already filtered out non-bindables, so we know we need a setProperty here\n        return new SetPropertyInstruction(symbol.rawValue, symbol.bindable.propName);\n      } else {\n        // either an element binding interpolation or a dynamic options attribute binding interpolation\n        return new InterpolationInstruction(symbol.expression as Interpolation, symbol.bindable.propName);\n      }\n    } else {\n      // either an element binding command, dynamic options attribute binding command,\n      // or custom attribute / template controller (single value) binding command\n      return symbol.command.compile(symbol) as HTMLAttributeInstruction;\n    }\n  }\n\n  private compileAttributes(symbol: IElementSymbol, offset: number): HTMLAttributeInstruction[] {\n    let attributeInstructions: HTMLAttributeInstruction[];\n    if (symbol.flags & SymbolFlags.hasAttributes) {\n      // any attributes on a custom element (which are not bindables) or a plain element\n      const { attributes } = symbol;\n      const len = attributes.length;\n      attributeInstructions = Array(offset + len);\n      for (let i = 0; i < len; ++i) {\n        attributeInstructions[i + offset] = this.compileAttribute(attributes[i]);\n      }\n    } else if (offset > 0) {\n      attributeInstructions = Array(offset);\n    } else {\n      attributeInstructions = PLATFORM.emptyArray as HTMLAttributeInstruction[];\n    }\n    return attributeInstructions;\n  }\n\n  private compileCustomAttribute(symbol: CustomAttributeSymbol): HTMLAttributeInstruction {\n    // a normal custom attribute (not template controller)\n    const bindings = this.compileBindings(symbol);\n    return new HydrateAttributeInstruction(symbol.res, bindings);\n  }\n\n  private compilePlainAttribute(symbol: PlainAttributeSymbol): HTMLAttributeInstruction {\n    if ((symbol as PlainAttributeSymbol).command === null) {\n      if (symbol.expression === null) {\n        // a plain attribute on a surrogate\n        return new SetAttributeInstruction(symbol.syntax.rawValue, symbol.syntax.target);\n      } else {\n        // a plain attribute with an interpolation\n        return new InterpolationInstruction(symbol.expression as Interpolation, symbol.syntax.target);\n      }\n    } else {\n      // a plain attribute with a binding command\n      return symbol.command.compile(symbol) as HTMLAttributeInstruction;\n    }\n  }\n\n  private compileAttribute(symbol: IAttributeSymbol): HTMLAttributeInstruction {\n    if (symbol.syntax.target === 'ref') {\n      return new RefBindingInstruction(symbol.syntax.rawValue);\n    }\n    // any attribute on a custom element (which is not a bindable) or a plain element\n    if (symbol.flags & SymbolFlags.isCustomAttribute) {\n      return this.compileCustomAttribute(symbol as CustomAttributeSymbol);\n    } else {\n      return this.compilePlainAttribute(symbol as PlainAttributeSymbol);\n    }\n  }\n\n  private compileParts(symbol: CustomElementSymbol): Record<string, ITemplateDefinition> {\n    let parts: Record<string, ITemplateDefinition>;\n    if (symbol.flags & SymbolFlags.hasParts) {\n      parts = {};\n      const replaceParts = symbol.parts;\n      const ii = replaceParts.length;\n      let instructionRowsSave: HTMLInstructionRow[];\n      let partInstructions: HTMLInstructionRow[];\n      let replacePart: ReplacePartSymbol;\n      for (let i = 0; i < ii; ++i) {\n        replacePart = replaceParts[i];\n        instructionRowsSave = this.instructionRows;\n        partInstructions = this.instructionRows = [];\n        this.compileParentNode(replacePart.template);\n        parts[replacePart.name] = {\n          name: replacePart.name,\n          template: replacePart.physicalNode,\n          instructions: partInstructions,\n          build: buildNotRequired\n        };\n        this.instructionRows = instructionRowsSave;\n      }\n    } else {\n      parts = PLATFORM.emptyObject;\n    }\n    return parts;\n  }\n}\n","import { JitConfiguration } from '@aurelia/jit';\nimport { DI, IContainer, IRegistry, Registration } from '@aurelia/kernel';\nimport { ITemplateCompiler } from '@aurelia/runtime';\nimport { HTMLRuntimeConfiguration } from '@aurelia/runtime-html';\nimport {\n  CaptureBindingCommand,\n  DelegateBindingCommand,\n  TriggerBindingCommand\n} from './binding-command';\nimport { TemplateCompiler } from './template-compiler';\nimport { HTMLTemplateElementFactory, ITemplateElementFactory } from './template-element-factory';\n\nexport const HTMLBindingLanguage: IRegistry[] = [\n  TriggerBindingCommand,\n  DelegateBindingCommand,\n  CaptureBindingCommand\n];\n\nexport const HTMLJitConfiguration = {\n  register(container: IContainer): void {\n    container.register(\n      HTMLRuntimeConfiguration,\n      JitConfiguration,\n      Registration.singleton(ITemplateCompiler, TemplateCompiler),\n      Registration.singleton(ITemplateElementFactory, HTMLTemplateElementFactory),\n      ...HTMLBindingLanguage\n    );\n  },\n  createContainer(): IContainer {\n    const container = DI.createContainer();\n    container.register(HTMLJitConfiguration);\n    return container;\n  }\n};\n","import { ITemplateDefinition, TargetedInstructionType } from '@aurelia/runtime';\nimport { HTMLTargetedInstruction, HTMLTargetedInstructionType, NodeType } from '@aurelia/runtime-html';\n\nexport function stringifyDOM(node: Node, depth: number): string {\n  const indent = ' '.repeat(depth);\n  let output = indent;\n  output += `Node: ${node.nodeName}`;\n  if (node.nodeType === NodeType.Text) {\n    output += ` \"${node.textContent}\"`;\n  }\n  if (node.nodeType === NodeType.Element) {\n    let i = 0;\n    let attr;\n    const attributes = (node as HTMLElement).attributes;\n    const len = attributes.length;\n    for (; i < len; ++i) {\n      attr = attributes[i];\n      output += ` ${attr.name}=${attr.value}`;\n    }\n  }\n  output += '\\n';\n  if (node.nodeType === NodeType.Element) {\n    let i = 0;\n    let childNodes = node.childNodes;\n    let len = childNodes.length;\n    for (; i < len; ++i) {\n      output += stringifyDOM(childNodes[i], depth + 1);\n    }\n    if (node.nodeName === 'TEMPLATE') {\n      i = 0;\n      childNodes = (node as HTMLTemplateElement).content.childNodes;\n      len = childNodes.length;\n      for (; i < len; ++i) {\n        output += stringifyDOM(childNodes[i], depth + 1);\n      }\n    }\n  }\n  return output;\n}\n\nexport function stringifyInstructions(instruction: HTMLTargetedInstruction, depth: number): string {\n  const indent = ' '.repeat(depth);\n  let output = indent;\n  switch (instruction.type) {\n    case HTMLTargetedInstructionType.textBinding:\n      output += 'textBinding\\n';\n      break;\n    case TargetedInstructionType.callBinding:\n      output += 'callBinding\\n';\n      break;\n    case TargetedInstructionType.iteratorBinding:\n      output += 'iteratorBinding\\n';\n      break;\n    case HTMLTargetedInstructionType.listenerBinding:\n      output += 'listenerBinding\\n';\n      break;\n    case TargetedInstructionType.propertyBinding:\n      output += 'propertyBinding\\n';\n      break;\n    case TargetedInstructionType.refBinding:\n      output += 'refBinding\\n';\n      break;\n    case HTMLTargetedInstructionType.stylePropertyBinding:\n      output += 'stylePropertyBinding\\n';\n      break;\n    case TargetedInstructionType.setProperty:\n      output += 'setProperty\\n';\n      break;\n    case HTMLTargetedInstructionType.setAttribute:\n      output += 'setAttribute\\n';\n      break;\n    case TargetedInstructionType.interpolation:\n      output += 'interpolation\\n';\n      break;\n    case TargetedInstructionType.hydrateLetElement:\n      output += 'hydrateLetElement\\n';\n      instruction.instructions.forEach(i => {\n        output += stringifyInstructions(i, depth + 1);\n      });\n      break;\n    case TargetedInstructionType.hydrateAttribute:\n      output += `hydrateAttribute: ${instruction.res}\\n`;\n      instruction.instructions.forEach(i => {\n        output += stringifyInstructions(i as HTMLTargetedInstruction, depth + 1);\n      });\n      break;\n    case TargetedInstructionType.hydrateElement:\n      output += `hydrateElement: ${instruction.res}\\n`;\n      instruction.instructions.forEach(i => {\n        output += stringifyInstructions(i as HTMLTargetedInstruction, depth + 1);\n      });\n      break;\n    case TargetedInstructionType.hydrateTemplateController:\n      output += `hydrateTemplateController: ${instruction.res}\\n`;\n      output += stringifyTemplateDefinition(instruction.def, depth + 1);\n      instruction.instructions.forEach(i => {\n        output += stringifyInstructions(i as HTMLTargetedInstruction, depth + 1);\n      });\n  }\n  return output;\n}\n\nexport function stringifyTemplateDefinition(def: ITemplateDefinition, depth: number): string {\n  const indent = ' '.repeat(depth);\n  let output = indent;\n\n  output += `TemplateDefinition: ${def.name}\\n`;\n  output += stringifyDOM(def.template as Node, depth + 1);\n  output += `${indent} Instructions:\\n`;\n  def.instructions.forEach(row => {\n    output += `${indent}  Row:\\n`;\n    row.forEach(i => {\n      output += stringifyInstructions(i as HTMLTargetedInstruction, depth + 3);\n    });\n  });\n\n  return output;\n}\n"],"names":[],"mappings":"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"}