import { IContainer, Key } from '@aurelia/kernel';
import { ForOfStatement } from '../../binding/ast';
import { IAttributeDefinition } from '../../definitions';
import { INode, IRenderLocation } from '../../dom';
import { LifecycleFlags as LF } from '../../flags';
import { IController, IViewFactory } from '../../lifecycle';
import { ILifecycleTask } from '../../lifecycle-task';
import { CollectionObserver, IndexMap, InlineObserversLookup, IObservable, IObservedArray, ObservedCollection } from '../../observation';
import { ICustomAttributeResource } from '../custom-attribute';
declare type Items<C extends ObservedCollection = IObservedArray> = C | undefined;
export declare class Repeat<C extends ObservedCollection = IObservedArray, T extends INode = INode> implements IObservable {
    items: Items<C>;
    static readonly inject: readonly Key[];
    static readonly kind: ICustomAttributeResource;
    static readonly description: Required<IAttributeDefinition>;
    readonly id: number;
    readonly $observers: InlineObserversLookup<this>;
    forOf: ForOfStatement;
    hasPendingInstanceMutation: boolean;
    local: string;
    location: IRenderLocation<T>;
    observer?: CollectionObserver;
    renderable: IController<T>;
    factory: IViewFactory<T>;
    views: IController<T>[];
    key?: string;
    readonly noProxy: true;
    $controller: IController<T>;
    private task;
    private _items;
    private normalizedItems?;
    constructor(location: IRenderLocation<T>, renderable: IController<T>, factory: IViewFactory<T>);
    static register(container: IContainer): void;
    binding(flags: LF): ILifecycleTask;
    attaching(flags: LF): void;
    detaching(flags: LF): void;
    unbinding(flags: LF): ILifecycleTask;
    itemsChanged(flags: LF): void;
    handleCollectionChange(indexMap: IndexMap | undefined, flags: LF): void;
    private processViewsKeyed;
    private checkCollectionObserver;
    private normalizeToArray;
    private detachViewsByRange;
    private unbindAndRemoveViewsByRange;
    private detachViewsByKey;
    private unbindAndRemoveViewsByKey;
    private createAndBindAllViews;
    private createAndBindNewViewsByKey;
    private attachViews;
    private attachViewsKeyed;
    private sortViewsByKey;
}
export {};
//# sourceMappingURL=repeat.d.ts.map