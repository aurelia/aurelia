import { Primitive } from '@aurelia/kernel';
export declare type BoxedPrimitive = Number | Boolean | String | Symbol;
export declare type IntArray = Int8Array | Int16Array | Int32Array | Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array;
export declare type FloatArray = Float32Array | Float64Array;
export declare type TypedArray = IntArray | FloatArray;
export declare type IntArrayConstructor = Int8ArrayConstructor | Int16ArrayConstructor | Int32ArrayConstructor | Uint8ArrayConstructor | Uint8ClampedArrayConstructor | Uint16ArrayConstructor | Uint32ArrayConstructor;
export declare type FloatArrayConstructor = Float32ArrayConstructor | Float64ArrayConstructor;
export declare type TypedArrayConstructor = IntArrayConstructor | FloatArrayConstructor;
export declare const getPrototypeOf: (o: any) => any, getOwnPropertyDescriptor: (o: any, p: string | number | symbol) => PropertyDescriptor | undefined, getOwnPropertyDescriptors: <T>(o: T) => { [P in keyof T]: TypedPropertyDescriptor<T[P]>; } & {
    [x: string]: PropertyDescriptor;
}, getOwnPropertyNames: (o: any) => string[], getOwnPropertySymbols: (o: any) => symbol[], defineProperty: (o: any, p: string | number | symbol, attributes: PropertyDescriptor & ThisType<any>) => any, defineProperties: (o: any, properties: PropertyDescriptorMap & ThisType<any>) => any;
export declare const Object_keys: {
    (o: object): string[];
    (o: {}): string[];
};
export declare const Object_is: (value1: any, value2: any) => boolean;
export declare const Object_freeze: {
    <T>(a: T[]): readonly T[];
    <T_1 extends Function>(f: T_1): T_1;
    <T_2>(o: T_2): Readonly<T_2>;
};
export declare const Object_assign: {
    <T, U>(target: T, source: U): T & U;
    <T_1, U_1, V>(target: T_1, source1: U_1, source2: V): T_1 & U_1 & V;
    <T_2, U_2, V_1, W>(target: T_2, source1: U_2, source2: V_1, source3: W): T_2 & U_2 & V_1 & W;
    (target: object, ...sources: any[]): any;
};
export declare const Object_create: {
    (o: object | null): any;
    (o: object | null, properties: PropertyDescriptorMap & ThisType<any>): any;
};
export declare const Number_isNaN: (number: number) => boolean;
export declare const Reflect_apply: typeof Reflect.apply;
export declare const ArrayBuffer_isView: (arg: any) => arg is ArrayBufferView;
export declare function uncurryThis<TArgs extends any[], TRet>(func: (...args: TArgs) => TRet): (thisArg: unknown, ...args: TArgs) => TRet;
export declare const hasOwnProperty: (thisArg: unknown, v: string | number | symbol) => boolean;
export declare const propertyIsEnumerable: (thisArg: unknown, v: string | number | symbol) => boolean;
export declare const TypedArrayPrototype: any;
export declare const Object_toString: (thisArg: unknown) => string;
export declare const RegExp_toString: (thisArg: unknown) => string;
export declare const Date_toISOString: (thisArg: unknown) => string;
export declare const Date_toString: (thisArg: unknown) => string;
export declare const Error_toString: (thisArg: unknown) => string;
export declare const Date_getTime: (thisArg: unknown) => number;
export declare const Set_values: (thisArg: unknown) => IterableIterator<any>;
export declare const Map_entries: (thisArg: unknown) => IterableIterator<[any, any]>;
export declare const Boolean_valueOf: (thisArg: unknown) => boolean;
export declare const Number_valueOf: (thisArg: unknown) => number;
export declare const Symbol_valueOf: (thisArg: unknown) => symbol;
export declare const String_valueOf: (thisArg: unknown) => string;
export declare function createNullObject<T>(input: T): Readonly<T>;
export declare function createFrozenNullObject<T>(input: T): Readonly<T>;
export declare function isBoolean(arg: unknown): arg is boolean;
export declare function isNull(arg: unknown): arg is null;
export declare function isNullOrUndefined(arg: unknown): arg is null | undefined;
export declare function isNumber(arg: unknown): arg is number;
export declare function isString(arg: unknown): arg is string;
export declare function isSymbol(arg: unknown): arg is symbol;
export declare function isUndefined(arg: unknown): arg is undefined;
export declare function isObject(arg: unknown): arg is Object;
export declare function isFunction(arg: unknown): arg is Function;
export declare function isPrimitive(arg: unknown): arg is Primitive;
export declare function isArrayBuffer(arg: unknown): arg is ArrayBuffer;
export declare function isSharedArrayBuffer(arg: unknown): arg is SharedArrayBuffer;
export declare function isAnyArrayBuffer(arg: unknown): arg is ArrayBuffer | SharedArrayBuffer;
export declare function isDate(arg: unknown): arg is Date;
export declare function isMap(arg: unknown): arg is Map<any, any>;
export declare function isMapIterator(arg: unknown): arg is IterableIterator<[any, any]>;
export declare function isRegExp(arg: unknown): arg is RegExp;
export declare function isSet(arg: unknown): arg is Set<any>;
export declare function isSetIterator(arg: unknown): arg is IterableIterator<[any, any]>;
export declare function isError(arg: unknown): arg is Error;
export declare function isNumberObject(arg: unknown): arg is Number;
export declare function isStringObject(arg: unknown): arg is String;
export declare function isBooleanObject(arg: unknown): arg is Boolean;
export declare function isSymbolObject(arg: unknown): arg is Symbol;
export declare function isBoxedPrimitive(arg: unknown): arg is BoxedPrimitive;
export declare function isTypedArray(value: unknown): value is TypedArray;
export declare function isUint8Array(value: unknown): value is Uint8Array;
export declare function isUint8ClampedArray(value: unknown): value is Uint8ClampedArray;
export declare function isUint16Array(value: unknown): value is Uint16Array;
export declare function isUint32Array(value: unknown): value is Uint32Array;
export declare function isInt8Array(value: unknown): value is Int8Array;
export declare function isInt16Array(value: unknown): value is Int16Array;
export declare function isInt32Array(value: unknown): value is Int32Array;
export declare function isFloat32Array(value: unknown): value is Float32Array;
export declare function isFloat64Array(value: unknown): value is Float64Array;
export declare function isArgumentsObject(value: unknown): value is IArguments;
export declare function isDataView(value: unknown): value is DataView;
export declare function isPromise(value: unknown): value is Promise<any>;
export declare function isWeakSet(value: unknown): value is WeakSet<any>;
export declare function isWeakMap(value: unknown): value is WeakMap<any, any>;
export declare function getOwnNonIndexProperties(val: ArrayLike<any> | ArrayBufferLike | ArrayBufferView, showHidden: boolean): string[];
export declare function getEnumerables(val: unknown, keys: PropertyKey[]): PropertyKey[];
interface IColors {
    bold(str: string): string;
    italic(str: string): string;
    underline(str: string): string;
    inverse(str: string): string;
    white(str: string): string;
    grey(str: string): string;
    black(str: string): string;
    blue(str: string): string;
    cyan(str: string): string;
    green(str: string): string;
    magenta(str: string): string;
    red(str: string): string;
    yellow(str: string): string;
}
export declare const colors: Readonly<IColors>;
export declare function removeColors(str: string): string;
export declare function join(output: string[], separator: string): string;
export declare function escapeAndQuoteString(str: string): string;
export declare function escapeString(str: string): string;
export declare function truncate<T>(s: T, n: number): T;
export declare const trimFull: (input: string) => string;
declare type AnyFunction = (...args: unknown[]) => unknown;
declare type VoidFunction = (...args: unknown[]) => void;
export declare type ISpy<T extends AnyFunction = AnyFunction> = T & {
    readonly calls: (readonly unknown[])[];
    restore(): void;
    reset(): void;
};
export declare function createSpy<T extends {}, K extends keyof T>(instance: T, key: K): T[K] extends AnyFunction ? ISpy<T[K]> : never;
export declare function createSpy<T extends {}, K extends keyof T, F extends AnyFunction>(instance: T, key: K, innerFn: F): T[K] extends AnyFunction ? ISpy<T[K]> : never;
export declare function createSpy<T extends {}, K extends keyof T>(instance: T, key: K, callThrough: true): T[K] extends AnyFunction ? ISpy<T[K]> : never;
export declare function createSpy<T extends AnyFunction = VoidFunction>(innerFn: T): ISpy<T>;
export declare function createSpy(): ISpy<VoidFunction>;
export {};
//# sourceMappingURL=util.d.ts.map